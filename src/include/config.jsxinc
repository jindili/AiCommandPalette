// CONFIGURATION

// ENVIRONMENT VARIABLES

var aiVersion = parseFloat(app.version);
var locale = $.locale;
var os = $.os;
var sysOS = /mac/i.test(os) ? "mac" : "win";
var windowsFlickerFix = sysOS === "win" && aiVersion < 26.4 ? true : false;
var settingsRequiredUpdateVersion = "0.10.0";

// DEVELOPMENT SETTINGS

// localization testing
// $.locale = false;
// $.locale = "de";
// $.locale = "ru";

// DIALOG SETTINGS

var paletteSettings = {};
paletteSettings.paletteWidth = 600;
// was informed windows and mac have different listbox row hights so this makes sure exactly 9 rows show
paletteSettings.paletteHeight = sysOS === "win" ? 211 : 201;
paletteSettings.bounds = [
  0,
  0,
  paletteSettings.paletteWidth,
  paletteSettings.paletteHeight,
];

paletteSettings.defaultColumns = {
  Name: { width: 475, key: "localizedName" },
  Type: { width: 100, key: "localizedType" },
};

var visibleListItems = 9;
var recentCommandsCount = 25;

// MISCELLANEOUS SETTINGS

var namedObjectLimit = 2000;

//USER SETTINGS

var settingsFolderName = "JBD";
var settingsFolder = setupFolderObject(Folder.userData + "/" + settingsFolderName);
var settingsFileName = "AiCommandPaletteSettings.json";

var settings = {};
settings.folder = function () {
  return settingsFolder;
};
settings.file = function () {
  var folder = this.folder();
  var file = setupFileObject(folder, settingsFileName);
  return file;
};
settings.load = function () {
  var file = this.file();
  if (file.exists) {
    try {
      var settings = readJSONData(file);
      if (settings == {}) return; // FIXME: add alert
      for (var prop in settings) {
        for (var subProp in settings[prop]) {
          data[prop][subProp] = settings[prop][subProp];
        }
      }
    } catch (e) {
      file.rename(file.name + ".bak");
      this.reveal();
      Error.runtimeError(1, localize(locStrings.pref_file_loading_error));
    }
  }
};
settings.save = function () {
  var file = this.file();
  var obj = {
    commands: {
      bookmark: data.commands.bookmark,
      script: data.commands.script,
      workflow: data.commands.workflow,
    },
    settings: {
      hidden: data.settings.hidden,
      name: _title,
      version: _version,
      os: os,
      locale: locale,
      aiVersion: aiVersion,
      searchIncludesType: data.settings.searchIncludesType,
      startupCommands: data.settings.startupCommands,
    },
    recent: data.recent,
  };
  writeJSONData(obj, file);
};
settings.backup = function () {
  var backupFile = new File(this.file() + ".bak");
  this.file().copy(backupFile);
};
settings.reveal = function () {
  var folder = this.folder();
  folder.execute();
};

settings.versionCheck = function () {
  // if the pref file is so old it doesn't have version info, just backup and start over
  if (!data.settings.hasOwnProperty("version")) {
    alert(localize(locStrings.pref_file_non_compatible));
    settings.backup();
    this.file.remove();
    return;
  }

  // if the settings >= the minimum required update version just continue
  var settingsVersion = data.settings.version;

  if (semanticVersionComparison(settingsVersion, settingsRequiredUpdateVersion) >= 0)
    return;

  // warn user about required settings update and backup their current settings
  alert(localize(locStrings.pref_file_non_compatible));
  settings.backup();
  if (semanticVersionComparison(settingsVersion, "0.8.1") < 0) {
    data.commands.workflow = updateOldWorkflows();
    data.commands.bookmark = updateOldBookmarks();
    data.commands.script = updateOldScripts();
    data.settings.hidden = updateOldHiddens();
    data.recent.commands = [];
  }
  if (semanticVersionComparison(settingsVersion, "0.10.0") < 0) {
    data.settings.startupCommands = updateStartupScreen();
    data.settings.searchIncludesType = true;
  }

  // save the updated settings file and continue with script
  settings.save();
  alert(localize(locStrings.pref_update_complete));
};

function updateOldWorkflows() {
  updatedWorkflows = {};
  updatedActions = [];
  var currentWorkflow, currentActions, currentAction;
  for (var workflow in data.commands.workflow) {
    currentWorkflow = data.commands.workflow[workflow];
    currentActions = currentWorkflow.actions;
    for (var i = 0; i < currentActions.length; i++) {
      currentAction = currentActions[i];
      if (!localizedCommandLookup.hasOwnProperty(currentAction)) {
        alert(
          "Workflow Update Error\n" +
            "Workflow command '" +
            currentAction +
            "' couldn't be updated.\n\nThe command has been removed from your '" +
            workflow.replace("Workflow: ", "") +
            "' workflow."
        );
        continue;
      }
      updatedActions.push(localizedCommandLookup[currentAction]);
    }
    updatedWorkflows[currentWorkflow.name] = {
      type: "workflow",
      actions: updatedActions,
    };
  }
  return updatedWorkflows;
}

function updateOldBookmarks() {
  updatedBookmarks = {};
  var currentBookmark;
  for (var bookmark in data.commands.bookmark) {
    currentBookmark = data.commands.bookmark[bookmark];
    updatedBookmarks[currentBookmark.name] = {
      type: "bookmark",
      path: currentBookmark.path,
      bookmarkType: currentBookmark.bookmarkType,
    };
  }
  return updatedBookmarks;
}

function updateOldScripts() {
  updatedScripts = {};
  var currentScript;
  for (var script in data.commands.script) {
    currentScript = data.commands.script[script];
    updatedScripts[currentScript.name] = {
      type: "script",
      path: currentScript.path,
    };
  }
  return updatedScripts;
}

function updateOldHiddens() {
  updatedHiddenCommands = [];
  var hiddenCommand;
  for (var i = 0; i < data.settings.hidden.length; i++) {
    hiddenCommand = data.settings.hidden[i];
    if (localizedCommandLookup.hasOwnProperty(hiddenCommand)) {
      updatedHiddenCommands.push(localizedCommandLookup[hiddenCommand]);
    }
  }
  return updatedHiddenCommands;
}

function updateOldRecents() {
  updatedRecentCommands = [];
  var recentCommand;
  for (var i = 0; i < data.recent.commands.length; i++) {
    recentCommand = data.recent.commands[i];
    if (localizedCommandLookup.hasOwnProperty(recentCommand)) {
      updatedRecentCommands.push(localizedCommandLookup[recentCommand]);
    }
  }
  return updatedRecentCommands;
}

function updateStartupScreen() {
  var oldStartupCommands = filterCommands(
    (commands = commandsData),
    (types = ["bookmark", "script", "workflow"]),
    (showHidden = false),
    (hideCommands = null),
    (docRequired = true),
    (selRequired = true)
  );
  var startupCommands = [];
  for (var i = 0; i < oldStartupCommands.length; i++) {
    startupCommands.push(oldStartupCommands[i].id);
  }
  startupCommands.push("builtin_recentCommands", "config_settings");
  return startupCommands;
}

// DEVELOPMENT HELPERS

var devInfo = {};
devInfo.folder = function () {
  return settingsFolder;
};
devInfo.dataFile = function () {
  var folder = this.folder();
  var file = setupFileObject(folder, "data.json");
  return file;
};
devInfo.commandsFile = function () {
  var folder = this.folder();
  var file = setupFileObject(folder, "commands.json");
  return file;
};
devInfo.save = function () {
  writeJSONData(data, this.dataFile());
  writeJSONData(commandsData, this.commandsFile());
};

/**
 * Show an alert with all object data for a command.
 * @param command Command to show data about.
 */
function alertCommandData(command) {
  var s = "";
  for (var prop in command) {
    var subS = "";
    if (typeof command[prop] == "object") {
      for (var subProp in command[prop]) {
        subS += "> " + subProp + ": " + command[prop][subProp] + "\n";
      }
      s += prop + ":\n" + subS;
    } else {
      s += prop + ": " + command[prop] + "\n";
    }
  }
  alert(s);
}
