// COMMANDS SETUP

/**
 * Build proper command objects for easy access.
 * @param commands  Command objects to build.
 * @param filterOut Command types to ignore.
 */
function buildCommands(commands, filterOut) {
  var type;
  for (type in commands) {
    if (filterOut && filterOut.includes(type)) continue;
    var command, commandData, hidden;
    for (command in commands[type]) {
      commandData = commands[type][command];
      hidden = false;
      // hide user hidden commands
      if (data.settings.hidden.includes(command)) hidden = true;
      // hide `Edit Workflow...` command if no workflows
      if (
        command == "config_editWorkflow" &&
        Object.keys(data.commands.workflow).length < 1
      )
        hidden = true;
      // hide `All Workflows...` command if no workflows
      if (
        command == "config_allWorkflows" &&
        Object.keys(data.commands.workflow).length < 1
      )
        hidden = true;
      // hide `All Scripts...` command if no scripts
      if (
        command == "config_allScripts" &&
        Object.keys(data.commands.script).length < 1
      )
        hidden = true;
      // hide `All Bookmarks...` command if no bookmarks
      if (
        command == "config_allBookmarks" &&
        Object.keys(data.commands.bookmark).length < 1
      )
        hidden = true;
      // hide `All Actions...` command if no actions
      if (
        command == "config_allActions" &&
        Object.keys(data.commands.action).length < 1
      )
        hidden = true;
      // hide `Enable Searching on Command Type` command if already enabled
      if (command == "config_enableTypeInSearch" && data.settings.searchIncludesType)
        hidden = true;
      // hide `Disable Searching on Command Type` command if already disabled
      if (command == "config_disableTypeInSearch" && !data.settings.searchIncludesType)
        hidden = true;
      // hide `Unhide Commands...` command if no hidden commands
      if (command == "config_unhideCommand" && data.settings.hidden.length < 1)
        hidden = true;
      // // hide `Recent Commands...` and `Clear Recent Commands` if no recent commands
      if (command == "builtin_recentCommands" && data.recent.commands.length == 0) {
        hidden = true;
      }
      if (command == "config_clearRecentCommands" && data.recent.commands.length == 0)
        hidden = true;
      commandData.id = command;
      commandData.localizedName = commandData.hasOwnProperty("loc")
        ? localize(commandData.loc)
        : command;
      commandData.localizedType = strings.hasOwnProperty(commandData.type)
        ? localize(strings[commandData.type])
        : commandData.type;
      commandsData[command] = commandData;
      localizedCommand = commandData.hasOwnProperty("loc")
        ? localize(commandData.loc)
        : command;
      localizedCommandLookup[localizedCommand] = command;
      if (hidden) hiddenCommands.push(command);
    }
  }
}

function loadActions() {
  var currentPath, set, actionCount, name;
  var pref = app.preferences;
  var path = "plugin/Action/SavedSets/set-";

  for (var i = 1; i <= 100; i++) {
    currentPath = path + i.toString() + "/";
    // get action sets
    set = pref.getStringPreference(currentPath + "name");
    if (!set) {
      break;
    }
    // get actions in set
    actionCount = Number(pref.getIntegerPreference(currentPath + "actionCount"));
    var name, key;
    for (var j = 1; j <= actionCount; j++) {
      name = pref.getStringPreference(currentPath + "action-" + j.toString() + "/name");
      key = name + " [" + set + "]";
      data.commands.action[key] = { name: name, type: "action", set: set };
    }
  }
}

function updateRecentCommands(command) {
  if (command.id == "builtin_recentCommands") return;
  // make sure command isn't already in the list
  var idx = data.recent.commands.indexOf(command.id);
  if (idx > -1) data.recent.commands.splice(idx, 1);
  data.recent.commands.unshift(command.id);
  // keep list at 10 items
  if (data.recent.commands.length > recentCommandsCount) data.recent.commands.pop();
  settings.save();
}

// COMMAND EXECUTION

/**
 * Iterate over each action for chosen command.
 * @param {Object} id Command id/key to execute.
 */
function processCommand(id) {
  var command = commandsData[id];
  if (command.type == "workflow") {
    insideWorkflow = true;
    // check to make sure all workflow commands are valid
    check = checkWorkflowActions(command.actions);
    if (check.deletedActions.length + check.incompatibleActions.length > 0) {
      alert(
        localize(
          strings.wf_needs_attention,
          check.deletedActions,
          check.incompatibleActions
        )
      );
      return;
    }
    // update recent commands list
    updateRecentCommands(command);
    // run each action in the workflow
    actions = command.actions;
    for (var i = 0; i < actions.length; i++) processCommand(commandsData[actions[i]]);
  } else {
    // update recent commands list
    if (!insideWorkflow) {
      updateRecentCommands(command);
    }
    executeCommand(command);
  }
}

/**
 * Execute command action.
 * @param {Object} command Command to execute.
 */
function executeCommand(command) {
  // check command to see if an active document is required
  appDocuments = app.documents.length > 0;
  if (!appDocuments && command.docRequired)
    if (
      !confirm(
        localize(strings.cd_active_document_required, command.action),
        "noAsDflt",
        localize(strings.cd_exception)
      )
    )
      return;
  // check command to see if an active selection is required
  if (appDocuments && app.activeDocument.selection.length < 1 && command.selRequired)
    if (
      !confirm(
        localize(strings.cd_active_selection_required, command.action),
        "noAsDflt",
        localize(strings.cd_exception)
      )
    )
      return;
  switch (command.type.toLowerCase()) {
    case "config":
      try {
        scriptAction(command.action);
      } catch (e) {
        alert(localize(strings.cd_error_executing, command.localizedName, e));
      }
      break;
    case "builtin":
      try {
        builtinAction(command.action);
      } catch (e) {
        alert(localize(strings.cd_error_executing, command.localizedName, e));
      }
      break;
    case "menu":
      try {
        app.executeMenuCommand(command.action);
      } catch (e) {
        alert(localize(strings.cd_error_executing, command.localizedName, e));
      }
      break;
    case "tool":
      try {
        app.selectTool(command.action);
      } catch (e) {
        alert(localize(strings.tl_error_selecting, command, e));
      }
      break;
    case "action":
      try {
        app.doScript(command.name, command.set);
      } catch (e) {
        alert(localize(strings.ac_error_execution, command, e));
      }
      break;
    case "bookmark":
      f =
        command.bookmarkType == "file"
          ? new File(command.path)
          : new Folder(command.path);
      if (!f.exists) {
        alert(localize(strings.bm_error_exists, command.path));
        delete data.commands.bookmark[command];
        settings.save();
      } else {
        try {
          if (command.bookmarkType == "file") {
            app.open(f);
          } else {
            f.execute();
          }
        } catch (e) {
          alert(localize(strings.sc_error_execution, command.name, e));
        }
      }
      break;
    case "script":
      f = new File(command.path);
      if (!f.exists) {
        alert(localize(strings.sc_error_exists, command.path));
        delete data.commands.script[command];
        settings.save();
      } else {
        try {
          $.evalFile(f);
        } catch (e) {
          alert(localize(strings.sc_error_execution, command.name, e));
        }
      }
      break;
    default:
      alert(localize(strings.cd_invalid, command.type));
  }
  try {
    app.redraw();
  } catch (e) {
    $.writeln(e);
  }
}

/**************************************************
SUPPLEMENTAL COMMAND FUNCTIONS
**************************************************/

function versionCheck(command) {
  if (
    (command.hasOwnProperty("minVersion") && command.minVersion > aiVersion) ||
    (command.hasOwnProperty("maxVersion") && command.maxVersion < aiVersion)
  )
    return false;
  return true;
}
