// COMMAND EXECUTION

/**
 * Process command actions.
 * @param {String} id Command id to process.
 */
function processCommand(id) {
  var command = commandsData[id];
  if (command.type == "workflow") {
    // check to make sure all workflow commands are valid
    badActions = checkWorkflowActions(command.actions);
    if (check.length) {
      alert(localize(strings.wf_needs_attention, badActions.join("\n")));
      return;
    }
    // run each action in the workflow
    for (var i = 0; i < command.actions.length; i++)
      processCommand(commandsData[command.actions[i]]);
  } else {
    executeAction(command);
  }
}

/**
 * Execute command action.
 * @param {Object} command Command to execute.
 */
function executeAction(command) {
  // recheck active document and selection incase previous workflow action changed them
  appDocuments = app.documents.length > 0;
  docSelection = appDocuments ? app.activeDocument.selection.length > 0 : false;
  // check command to see if an active document is required
  if (command.docRequired && !appDocuments)
    if (
      !confirm(
        localize(strings.cd_active_document_required, command.action),
        "noAsDflt",
        localize(strings.cd_exception)
      )
    )
      return;

  // check command to see if an active selection is required
  if (command.selRequired && !docSelection)
    if (
      !confirm(
        localize(strings.cd_active_selection_required, command.action),
        "noAsDflt",
        localize(strings.cd_exception)
      )
    )
      return;

  // execute action based on the command type
  var func;
  var alertString = strings.cd_error_executing;
  switch (command.type.toLowerCase()) {
    case "config":
      func = configAction;
      break;
    case "builtin":
      func = builtinAction;
      break;
    case "menu":
      func = menuAction;
      break;
    case "tool":
      func = toolAction;
      alertString = strings.tl_error_selecting;
      break;
    case "action":
      func = actionAction;
      alertString = strings.ac_error_execution;
      break;
    case "bookmark":
    case "file":
    case "folder":
      func = bookmarkAction;
      break;
    case "script":
      func = scriptAction;
      alertString = strings.sc_error_execution;
      break;
    default:
      alert(localize(strings.cd_invalid, command.type));
  }

  try {
    func(command);
  } catch (e) {
    alert(localize(alertString, localize(command.name), e));
  }
}

function menuAction(command) {
  app.executeMenuCommand(command.action);
}

function toolAction(command) {
  app.selectTool(command.action);
}

function actionAction(command) {
  app.doScript(command.name, command.set);
}

function bookmarkAction(command) {
  f = command.type == "file" ? new File(command.path) : new Folder(command.path);
  if (!f.exists) {
    alert(localize(strings.bm_error_exists, command.path));
    return;
  }
  if (command.type == "file") {
    app.open(f);
  } else {
    f.execute();
  }
}

function scriptAction(command) {
  f = new File(command.path);
  if (!f.exists) {
    alert(localize(strings.sc_error_exists, command.path));
  } else {
    $.evalFile(f);
  }
}

/**
 * Execute script actions.
 * @param {Object} command Command to execute.
 */
function configAction(command) {
  var write = true;
  switch (command.action) {
    case "settings":
      AiCommandPaletteSettings();
      write = false;
      break;
    case "about":
      about();
      write = false;
      break;
    case "buildStartup":
      buildStartup();
      break;
    case "buildWorkflow": // TODO
      buildWorkflow();
      break;
    case "editWorkflow": // TODO
      editWorkflow();
      break;
    case "loadScript":
      loadScripts();
      break;
    case "loadFileBookmark":
      loadFileBookmark();
      write = true;
      break;
    case "loadFolderBookmark":
      loadFolderBookmark();
      break;
    case "hideCommand":
      hideCommand();
      break;
    case "unhideCommand":
      unhideCommand();
      break;
    case "deleteCommand": // TODO
      deleteCommand();
      break;
    case "enableTypeInSearch":
    case "disableTypeInSearch":
      prefs.searchIncludesType = !prefs.searchIncludesType;
      break;
    case "clearHistory": // FIXME: Update alert to include warning about latches
      if (
        !confirm(
          localize(strings.cd_clear_history_confirm),
          "noAsDflt",
          localize(strings.cd_exception)
        )
      )
        return;
      userHistory.clear();
      alert(localize(strings.history_cleared));
      break;
    case "revealPrefFile":
      userPrefs.reveal();
      write = false;
      break;
    default:
      alert(localize(strings.cd_invalid, action));
  }
  if (!write) return;
  userPrefs.save();
}

/**
 * Execute built-in commands.
 * @param {Object} command Command to execute.
 */
function builtinAction(command) {
  switch (command.action) {
    case "recentCommands":
      recentCommands();
      break;
    case "allWorkflows":
      showAllWorkflows();
      break;
    case "allScripts":
      showAllScripts();
      break;
    case "allBookmarks":
      showAllBookmarks();
      break;
    case "allActions":
      showAllActions();
      break;
    case "documentReport":
      if (activeDocument) documentReport();
      break;
    case "exportVariables":
      if (activeDocument) exportVariables();
      break;
    case "goToArtboard":
      if (activeDocument) goToArtboard();
      break;
    case "goToDocument":
      if (app.documents.length > 1) {
        goToOpenDocument();
      }
      break;
    case "goToNamedObject":
      if (activeDocument) goToNamedObject();
      break;
    case "imageCapture":
      imageCapture();
      break;
    case "recentFiles":
      recentFiles();
      break;
    case "redrawWindows":
      app.redraw();
      break;
    case "revealActiveDocument":
      if (activeDocument) {
        if (app.activeDocument.path.fsName) {
          var fp = new Folder(app.activeDocument.path.fsName);
          fp.execute();
        } else {
          alert(localize(strings.active_document_not_saved));
        }
      }
      break;
    default:
      alert(localize(strings.cd_invalid, action));
  }
}
