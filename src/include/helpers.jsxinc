/**
 * Check to see if there is an active document.
 * @returns Make sure at least one document is open for certain built-in commands.
 */
function activeDocument() {
  if (app.documents.length < 1) {
    alert(localize(locStrings.no_active_document));
    return false;
  }
  return true;
}

/**
 * Get every font used inside of an the Ai document.
 * @param {Object} doc Ai document.
 */
function getDocumentFonts(doc) {
  var fonts = [];
  for (var i = 0; i < doc.textFrames.length; i++) {
    for (var j = 0; j < doc.textFrames[i].textRanges.length; j++) {
      if (!fonts.includes(doc.textFrames[i].textRanges[j].textFont)) {
        fonts.push(doc.textFrames[i].textRanges[j].textFont);
      }
    }
  }
  return fonts;
}

/**
 * Convert Ai points unit to another api ruler constant.
 * https://ai-scripting.docsforadobe.dev/jsobjref/scripting-constants.html#jsobjref-scripting-constants-rulerunits
 * @param   {Number} points Point value to convert.
 * @param   {String} unit   RulerUnit to convert `points` to.
 * @returns {Number}        Converted number.
 */
function convertPointsTo(points, unit) {
  var conversions = {
    Centimeters: 28.346,
    Qs: 0.709,
    Inches: 72.0,
    Pixels: 1.0,
    Millimeters: 2.834645,
    Unknown: 1.0,
    Picas: 12.0,
    Points: 1.0,
  };
  return points / conversions[unit];
}

/**
 * Get info for all placed files for the current document.
 * @returns {Array} Placed file information.
 */
function getPlacedFileInfoForReport() {
  if (ExternalObject.AdobeXMPScript == undefined)
    ExternalObject.AdobeXMPScript = new ExternalObject("lib:AdobeXMPScript");
  //Read xmp string - You can see document XMP in Illustrator -> File-> File Info -> Raw Data
  var xmp = new XMPMeta(app.activeDocument.XMPString);

  var names = [];
  var allFilePaths = getAllPlacedFilePaths(xmp);
  // var brokenFilePaths = getBrokenFilePaths(xmp);

  // convert path to file object for property access
  var fileObjects = [];
  for (var i = 0; i < allFilePaths.length; i++) {
    fileObjects.push(new File(allFilePaths[i]));
  }
  // sort the files by name
  fileObjects.sort(function (a, b) {
    return a.name - b.name;
  });
  // build string with file info for the report
  var f;
  for (var i = 0; i < fileObjects.length; i++) {
    f = fileObjects[i];
    names.push(
      localize(locStrings.dr_name) +
        decodeURI(f.name) +
        "\n" +
        localize(locStrings.dr_path) +
        f.fsName.replace(f.name, "") +
        "\n" +
        localize(locStrings.dr_file_found) +
        f.exists.toString().toUpperCase() +
        (i == fileObjects.length - 1 ? "" : "\n")
    );
  }
  return names;
}

/**
 * Great trick to get all placed files (linked and embeded) @pixxxelschubser
 * https://community.adobe.com/t5/user/viewprofilepage/user-id/7720512
 *
 * If you try to do this using the placedItems collection from the API you will have issues.
 */

/**
 * Great trick to get all placed files (linked and embeded) @pixxxelschubser
 * https://community.adobe.com/t5/user/viewprofilepage/user-id/7720512
 *
 * If you try to do this using the placedItems collection from the API you will have issues.
 * @param   {String} xmp Document xml data.
 * @returns {Array}      Placed file paths.
 */
function getAllPlacedFilePaths(xmp) {
  //Read file paths from XMP - this returns file paths of both embedded and linked images
  var paths = [];
  var xpath;
  for (var i = 1; i <= xmp.countArrayItems(XMPConst.NS_XMP_MM, "Manifest"); i++) {
    xpath = "xmpMM:Manifest[" + i + "]/stMfs:reference/stRef:filePath";
    paths.push(xmp.getProperty(XMPConst.NS_XMP_MM, xpath).value);
  }
  return paths;
}

/**
 * Check for any placed files with broken links in the current document.
 * @param   {String} xmp Document xml data.
 * @returns {Array}      Broken placed file paths.
 */
function getBrokenFilePaths(xmp) {
  //Read file paths from XMP - this returns file paths of both embedded and linked images
  var paths = [];
  var xpath;
  for (var i = 1; i <= xmp.countArrayItems(XMPConst.NS_XMP_MM, "Ingredients"); i++) {
    xpath = "xmpMM:Ingredients[" + i + "]/stRef:filePath";
    paths.push(xmp.getProperty(XMPConst.NS_XMP_MM, xpath).value);
  }
  return paths;
}

/**
 * Return the names of each object in an Ai collection object.
 * https://ai-scripting.docsforadobe.dev/scripting/workingWithObjects.html?highlight=collection#collection-objects
 * @param   {Object} collection Ai collection object.
 * @returns {Array}             Names of each object inside of `collection`.
 */

/**
 * Return the names of each object in an Ai collection object.
 * https://ai-scripting.docsforadobe.dev/scripting/workingWithObjects.html?highlight=collection#collection-objects
 * @param {Object}  collection Ai collection object.
 * @param {Boolean} sorted     Should the results be sorted.
 * @returns {Array}            Names of each object inside of `collection`.
 */
function getCollectionObjectNames(collection, sorted) {
  sorted = typeof sorted !== "undefined" ? sorted : false;
  names = [];
  if (collection.length > 0) {
    for (var i = 0; i < collection.length; i++) {
      if (collection.typename == "Spots") {
        if (collection[i].name != "[Registration]") {
          names.push(collection[i].name);
        }
      } else {
        names.push(collection[i].name);
      }
    }
  }
  return sorted ? names.sort() : names;
}

/**
 * Return recently opened files as file objects (also found in File > Open Recent Files).
 * @returns {Array} Recent file paths.
 */
function getRecentFilePaths() {
  var path;
  var paths = [];
  var fileCount = app.preferences.getIntegerPreference("RecentFileNumber");
  for (var i = 0; i < fileCount; i++) {
    path = app.preferences.getStringPreference(
      "plugin/MixedFileList/file" + i + "/path"
    );
    paths.push(path);
  }
  return paths;
}

/**************************************************
DIALOG HELPER FUNCTIONS
**************************************************/

/**
 * Filter the supplied commands by multiple factors.
 * @param   {Object}  commands Command objects to filter.
 * @param   {Array}   types Types of commands to include in the results (e.g. builtin, tool, config, etc.).
 * @param   {Boolean} showHidden Should command hidden by the user be included?
 * @param   {Array}   hideSpecificCommands Future me including a hack to hide specific commands.
 * @param   {Boolean} docRequired Should commands requiring an active document be included.
 * @param   {Boolean} selRequired Should commands requiring an active selection be included.
 * @returns {Array}   Filtered commands in the form of {name: command name, type: command type}.
 */
function filterCommands(
  commands,
  types,
  showHidden,
  hideSpecificCommands,
  docRequired,
  selRequired
) {
  var filteredCommands = [];
  var prop, command;
  for (prop in commands) {
    // for (var i = 0; i < commands.length; i++) {
    command = commands[prop];
    // command = commandsData[commands[i]];
    // hide commands requiring an active documents if requested
    if (docRequired && !appDocuments && command.docRequired) continue;
    // hide commands requiring an active selection if requested
    if (selRequired && !docSelection && command.selRequired) continue;
    // make sure Ai version meets command requirements
    if (!versionCheck(command)) continue;
    // skip any hidden commands
    if (!showHidden && data.settings.hidden.includes(prop)) continue;
    // skip any specific commands name in hideSpecificCommands
    if (hideSpecificCommands && hideSpecificCommands.includes(prop)) continue;
    // then check to see if the command should be included
    if (!types || types.includes(command.type)) filteredCommands.push(command);
  }
  return filteredCommands;
}

/**
 * Score array items based on regex string match.
 * @param   {String} query    String to search for.
 * @param   {Array}  commands Commands to match on.
 * @returns {Array}           Matching items sorted by score.
 */
function scoreMatches(query, commands) {
  var regexEllipsis = /\.\.\.$/;
  var regexCarrot = /\s>\s/g;

  var words = [];
  var matches = [];
  var matchedCommands = [];
  var scores = {};
  var maxScore = 0;
  query = query.toLowerCase();
  var words = query.split(" ");
  var command, commandName, commandType, score, strippedString;
  for (var i = 0; i < commands.length; i++) {
    command = commands[i];
    commandName = command.localizedName.toLowerCase();
    commandType = command.localizedType.toLowerCase();
    strippedString = commandName.replace(regexEllipsis, "").replace(regexCarrot, " ");
    score = 0;

    // check for exact match
    if (
      query == commandName ||
      query.replace(regexEllipsis, "").replace(regexCarrot, " ") == strippedString ||
      (data.settings.searchIncludesType && query == commandType)
    ) {
      score += 1;
    }

    // check for singular word matches
    var word;
    for (var n = 0; n < words.length; n++) {
      word = words[n];
      if (!word) continue;
      if (
        commandName.match("\\b" + word, "gi") != null ||
        strippedString.match("\\b" + word, "gi") != null ||
        (data.settings.searchIncludesType &&
          commandType.match("\\b" + word, "gi") != null)
      )
        score += word.length;
    }

    // increase score if command found in recent commands
    if (
      score == maxScore &&
      data.recent.commands.indexOf(localizedCommandLookup[command.name]) > -1
    ) {
      score++;
    }

    // updated scores for matches
    if (score > 0) {
      scores[command.id] = score;
      matches.push(command);
      if (score > maxScore) maxScore = score;
    }
  }

  for (var m = 0; m < matches.length; m++) {
    if (scores[matches[m].id] >= maxScore / 2) matchedCommands.push(matches[m]);
  }

  // sort the matches by score
  matchedCommands.sort(function (a, b) {
    return scores[b.id] - scores[a.id];
  });

  return matchedCommands;
}

/**
 * Score array items based on regex string match.
 * @param   {String} query   String to search for.
 * @param   {Array}  objects Array of objects to search through.
 * @param   {String} prop    Object property to match on.
 * @returns {Array}          Matching items sorted by score.
 */
function scoreObjectMatches(query, objects, prop) {
  var word;
  var words = query.split(" ");
  var matches = [];
  for (var i = 0; i < objects.length; i++) {
    var score = 0;
    for (var n = 0; n < words.length; n++) {
      word = words[n];
      if (!objects[i].hasOwnProperty(prop)) continue;
      if (word != "" && objects[i][prop].match("(?:^|\\s)(" + word + ")", "gi") != null)
        score++;
    }
    if (score > 0) {
      objects[i].score = score;
      matches.push(objects[i]);
    }
  }
  // sort all matches by score
  matches.sort(function (a, b) {
    return b.score - a.score;
  });
  return matches;
}

/**
 * Simulate a key press for Windows users.
 *
 * This function is in response to a known ScriptUI bug on Windows.
 * You can read more about it in the GitHub issue linked below.
 * https://github.com/joshbduncan/AiCommandPalette/issues/8
 *
 * Basically, on some Windows Ai versions, when a ScriptUI dialog is
 * presented and the active attribute is set to true on a field, Windows
 * will flash the Windows Explorer app quickly and then bring Ai back
 * in focus with the dialog front and center. This is a terrible user
 * experience so Sergey and I attempted to fix it the best we could.
 *
 * This clever solution was created by Sergey Osokin (https://github.com/creold)
 *
 * @param {String} k Key to simulate.
 * @param {Number} n Number of times to simulate the keypress.
 */
function simulateKeypress(k, n) {
  if (!n) n = 1;
  try {
    var f = setupFileObject(settingsFolder, "SimulateKeypress.vbs");
    if (!f.exists) {
      var data = 'Set WshShell = WScript.CreateObject("WScript.Shell")\n';
      while (n--) {
        data += 'WshShell.SendKeys "{' + k + '}"\n';
      }
      f.encoding = "UTF-8";
      f.open("w");
      f.write(data);
      f.close();
    }
    f.execute();
  } catch (e) {
    $.writeln(e);
  }
}

/**
 * Open a url in the system browser.
 * @param {String} url URL to open.
 */
function openURL(url) {
  var html = new File(Folder.temp.absoluteURI + "/aisLink.html");
  html.open("w");
  var htmlBody =
    '<html><head><META HTTP-EQUIV=Refresh CONTENT="0; URL=' +
    url +
    '"></head><body> <p></body></html>';
  html.write(htmlBody);
  html.close();
  html.execute();
}

/**
 * Wrapper for helper functions that update a users preferences to the new format.
 */
function updateOldPreferences() {
  updateOldWorkflows();
  updateOldBookmarks();
  updateOldScripts();
  updateOldHiddens();
  data.settings.searchIncludesType = true;
  data.recent.commands = [];
}

function updateOldWorkflows() {
  updatedWorkflows = {};
  updatedActions = [];
  var currentWorkflow, currentActions, currentAction;
  for (var workflow in data.commands.workflow) {
    currentWorkflow = data.commands.workflow[workflow];
    currentActions = currentWorkflow.actions;
    for (var i = 0; i < currentActions.length; i++) {
      currentAction = currentActions[i];
      if (!localizedCommandLookup.hasOwnProperty(currentAction)) {
        alert(
          "Workflow Update Error\n" +
            "Workflow command '" +
            currentAction +
            "' couldn't be updated.\n\nThe command has been removed from your '" +
            workflow.replace("Workflow: ", "") +
            "' workflow."
        );
        continue;
      }
      updatedActions.push(localizedCommandLookup[currentAction]);
    }
    updatedWorkflows[currentWorkflow.name] = {
      type: "workflow",
      actions: updatedActions,
    };
  }
  data.commands.workflow = updatedWorkflows;
}

function updateOldBookmarks() {
  updatedBookmarks = {};
  var currentBookmark;
  for (var bookmark in data.commands.bookmark) {
    currentBookmark = data.commands.bookmark[bookmark];
    updatedBookmarks[currentBookmark.name] = {
      type: "bookmark",
      path: currentBookmark.path,
      bookmarkType: currentBookmark.bookmarkType,
    };
  }
  data.commands.bookmark = updatedBookmarks;
}

function updateOldScripts() {
  updatedScripts = {};
  var currentScript;
  for (var script in data.commands.script) {
    currentScript = data.commands.script[script];
    updatedScripts[currentScript.name] = {
      type: "script",
      path: currentScript.path,
    };
  }
  data.commands.script = updatedScripts;
}

function updateOldHiddens() {
  updatedHiddenCommands = [];
  var hiddenCommand;
  for (var i = 0; i < data.settings.hidden.length; i++) {
    hiddenCommand = data.settings.hidden[i];
    if (localizedCommandLookup.hasOwnProperty(hiddenCommand)) {
      updatedHiddenCommands.push(localizedCommandLookup[hiddenCommand]);
    }
  }
  data.settings.hidden = updatedHiddenCommands;
}

function updateOldRecents() {
  updatedRecentCommands = [];
  var recentCommand;
  for (var i = 0; i < data.recent.commands.length; i++) {
    recentCommand = data.recent.commands[i];
    if (localizedCommandLookup.hasOwnProperty(recentCommand)) {
      updatedRecentCommands.push(localizedCommandLookup[recentCommand]);
    }
  }
  data.recent.commands = updatedRecentCommands;
}
