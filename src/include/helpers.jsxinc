/**
 * Check to see if there is an active document.
 * @returns Make sure at least one document is open for certain built-in commands.
 */
function activeDocument() {
  if (app.documents.length < 1) {
    alert(localize(strings.no_active_document));
    return false;
  }
  return true;
}

/**
 * Compare semantic version numbers.
 * @param {String} a Semantic version number.
 * @param {String} b Semantic version number.
 * @returns          1 if `a` > `b`, -1 if `b` > `a`, 0 if `a` == `b`.
 */
function semanticVersionComparison(a, b) {
  if (a === b) {
    return 0;
  }

  var a_components = a.split(".");
  var b_components = b.split(".");

  var len = Math.min(a_components.length, b_components.length);

  // loop while the components are equal
  for (var i = 0; i < len; i++) {
    // A bigger than B
    if (parseInt(a_components[i]) > parseInt(b_components[i])) {
      return 1;
    }

    // B bigger than A
    if (parseInt(a_components[i]) < parseInt(b_components[i])) {
      return -1;
    }
  }

  // If one's a prefix of the other, the longer one is greater.
  if (a_components.length > b_components.length) {
    return 1;
  }

  if (a_components.length < b_components.length) {
    return -1;
  }
}

/**
 * Get every font used inside of an the Ai document.
 * @param {Object} doc Ai document.
 */
function getDocumentFonts(doc) {
  var fonts = [];
  for (var i = 0; i < doc.textFrames.length; i++) {
    for (var j = 0; j < doc.textFrames[i].textRanges.length; j++) {
      if (!fonts.includes(doc.textFrames[i].textRanges[j].textFont)) {
        fonts.push(doc.textFrames[i].textRanges[j].textFont);
      }
    }
  }
  return fonts;
}

/**
 * Convert Ai points unit to another api ruler constant.
 * https://ai-scripting.docsforadobe.dev/jsobjref/scripting-constants.html#jsobjref-scripting-constants-rulerunits
 * @param   {Number} points Point value to convert.
 * @param   {String} unit   RulerUnit to convert `points` to.
 * @returns {Number}        Converted number.
 */
function convertPointsTo(points, unit) {
  var conversions = {
    Centimeters: 28.346,
    Qs: 0.709,
    Inches: 72.0,
    Pixels: 1.0,
    Millimeters: 2.834645,
    Unknown: 1.0,
    Picas: 12.0,
    Points: 1.0,
  };
  return points / conversions[unit];
}

/**
 * Get info for all placed files for the current document.
 * @returns {Array} Placed file information.
 */
function getPlacedFileInfoForReport() {
  if (ExternalObject.AdobeXMPScript == undefined)
    ExternalObject.AdobeXMPScript = new ExternalObject("lib:AdobeXMPScript");
  //Read xmp string - You can see document XMP in Illustrator -> File-> File Info -> Raw Data
  var xmp = new XMPMeta(app.activeDocument.XMPString);

  var names = [];
  var allFilePaths = getAllPlacedFilePaths(xmp);
  // var brokenFilePaths = getBrokenFilePaths(xmp);

  // convert path to file object for property access
  var fileObjects = [];
  for (var i = 0; i < allFilePaths.length; i++) {
    fileObjects.push(new File(allFilePaths[i]));
  }
  // sort the files by name
  fileObjects.sort(function (a, b) {
    return a.name - b.name;
  });
  // build string with file info for the report
  var f;
  for (var i = 0; i < fileObjects.length; i++) {
    f = fileObjects[i];
    names.push(
      localize(strings.dr_name) +
        decodeURI(f.name) +
        "\n" +
        localize(strings.dr_path) +
        f.fsName.replace(f.name, "") +
        "\n" +
        localize(strings.dr_file_found) +
        f.exists.toString().toUpperCase() +
        (i == fileObjects.length - 1 ? "" : "\n")
    );
  }
  return names;
}

/**
 * Great trick to get all placed files (linked and embeded) @pixxxelschubser
 * https://community.adobe.com/t5/user/viewprofilepage/user-id/7720512
 *
 * If you try to do this using the placedItems collection from the API you will have issues.
 */

/**
 * Great trick to get all placed files (linked and embeded) @pixxxelschubser
 * https://community.adobe.com/t5/user/viewprofilepage/user-id/7720512
 *
 * If you try to do this using the placedItems collection from the API you will have issues.
 * @param   {String} xmp Document xml data.
 * @returns {Array}      Placed file paths.
 */
function getAllPlacedFilePaths(xmp) {
  //Read file paths from XMP - this returns file paths of both embedded and linked images
  var paths = [];
  var xpath;
  for (var i = 1; i <= xmp.countArrayItems(XMPConst.NS_XMP_MM, "Manifest"); i++) {
    xpath = "xmpMM:Manifest[" + i + "]/stMfs:reference/stRef:filePath";
    paths.push(xmp.getProperty(XMPConst.NS_XMP_MM, xpath).value);
  }
  return paths;
}

/**
 * Check for any placed files with broken links in the current document.
 * @param   {String} xmp Document xml data.
 * @returns {Array}      Broken placed file paths.
 */
function getBrokenFilePaths(xmp) {
  //Read file paths from XMP - this returns file paths of both embedded and linked images
  var paths = [];
  var xpath;
  for (var i = 1; i <= xmp.countArrayItems(XMPConst.NS_XMP_MM, "Ingredients"); i++) {
    xpath = "xmpMM:Ingredients[" + i + "]/stRef:filePath";
    paths.push(xmp.getProperty(XMPConst.NS_XMP_MM, xpath).value);
  }
  return paths;
}

/**
 * Return the names of each object in an Ai collection object.
 * https://ai-scripting.docsforadobe.dev/scripting/workingWithObjects.html?highlight=collection#collection-objects
 * @param   {Object} collection Ai collection object.
 * @returns {Array}             Names of each object inside of `collection`.
 */

/**
 * Return the names of each object in an Ai collection object.
 * https://ai-scripting.docsforadobe.dev/scripting/workingWithObjects.html?highlight=collection#collection-objects
 * @param {Object}  collection Ai collection object.
 * @param {Boolean} sorted     Should the results be sorted.
 * @returns {Array}            Names of each object inside of `collection`.
 */
function getCollectionObjectNames(collection, sorted) {
  sorted = typeof sorted !== "undefined" ? sorted : false;
  names = [];
  if (collection.length > 0) {
    for (var i = 0; i < collection.length; i++) {
      if (collection.typename == "Spots") {
        if (collection[i].name != "[Registration]") {
          names.push(collection[i].name);
        }
      } else {
        names.push(collection[i].name);
      }
    }
  }
  return sorted ? names.sort() : names;
}

/**
 * Return recently opened files as file objects (also found in File > Open Recent Files).
 * @returns {Array} Recent file paths.
 */
function getRecentFilePaths() {
  var path;
  var paths = [];
  var fileCount = app.preferences.getIntegerPreference("RecentFileNumber");
  for (var i = 0; i < fileCount; i++) {
    path = app.preferences.getStringPreference(
      "plugin/MixedFileList/file" + i + "/path"
    );
    paths.push(path);
  }
  return paths;
}

/**************************************************
DIALOG HELPER FUNCTIONS
**************************************************/

/**
 * Filter the supplied commands by multiple factors.
 * @param   {Array}   commandIds Command `id`s to filter through.
 * @param   {Array}   types Types of commands to include in the results (e.g. builtin, tool, config, etc.).
 * @param   {Boolean} showHidden Should user-hidden or non-relevant commands be included?
 * @param   {Array}   hideSpecificCommands Future me including a hack to hide specific commands.
 * @param   {Boolean} docRequired Should commands requiring an active document be included.
 * @param   {Boolean} selRequired Should commands requiring an active selection be included.
 * @returns {Array}   Filtered commands objects.
 */
function filterCommands(
  commands,
  types,
  showHidden,
  hideSpecificCommands,
  docRequired,
  selRequired
) {
  var filteredCommands = [];
  var id, command;
  commands = commands ? commands : Object.keys(commandsData);
  for (var i = 0; i < commands.length; i++) {
    id = commands[i];
    if (!commandsData.hasOwnProperty(id)) continue;
    command = commandsData[id];
    // hide commands requiring an active documents if requested
    if (docRequired && !appDocuments && command.docRequired) continue;
    // hide commands requiring an active selection if requested
    if (selRequired && !docSelection && command.selRequired) continue;
    // make sure Ai version meets command requirements
    if (!versionCheck(command)) continue;
    // skip any hidden commands
    if (!showHidden && command.hidden) continue;
    // skip any specific commands name in hideSpecificCommands
    if (hideSpecificCommands && hideSpecificCommands.includes(id)) continue;
    // then check to see if the command should be included
    if (!types || types.includes(command.type)) filteredCommands.push(command);
  }
  return filteredCommands;
}

/**
 * Score array items based on regex string match.
 * @param   {String} query    String to search for.
 * @param   {Array}  commands Commands to match on.
 * @returns {Array}           Matching items sorted by score.
 */
function scoreMatches(query, commands) {
  var words = [];
  var matches = [];
  var matchedCommands = [];
  var scores = {};
  var maxScore = 0;
  query = query.toLowerCase();
  var words = query.split(" ");
  var command, name, type, score, strippedString;
  for (var i = 0; i < commands.length; i++) {
    command = commands[i];
    if (command.hasOwnProperty("loc")) {
      name = localize(command.loc).toLowerCase();
    } else if (command.hasOwnProperty("name")) {
      name = command.name.toLowerCase();
    } else {
      name = command.id.toLowerCase().replace("_", " "); // FIXME: not sure about this
    }
    if (strings.hasOwnProperty(command.type)) {
      type = localize(strings[command.type]).toLowerCase();
    } else {
      type = command.type.toLowerCase();
    }
    strippedString = name.replace(regexEllipsis, "").replace(regexCarrot, " ");
    score = 0;

    // check for exact match
    if (
      query == name ||
      query.replace(regexEllipsis, "").replace(regexCarrot, " ") == strippedString
    ) {
      score += 1;
    }

    // check for type match
    // FIXME: reenable
    // if (data.settings.searchIncludesType && query == type) {
    //   score += 1;
    // }

    // check for singular word matches
    var word;
    for (var n = 0; n < words.length; n++) {
      word = words[n];
      if (!word) continue;
      // FIXME: reenable
      // if (
      //   name.match("\\b" + word, "gi") != null ||
      //   strippedString.match("\\b" + word, "gi") != null ||
      //   (data.settings.searchIncludesType && type.match("\\b" + word, "gi") != null)
      // )
      if (
        name.match("\\b" + word, "gi") != null ||
        strippedString.match("\\b" + word, "gi") != null
      )
        score += word.length;
    }

    // updated scores for matches
    if (score > 0) {
      // increase score if command found in recent commands
      // FIXME: reenable
      // if (score == maxScore && data.recent.commands.indexOf(command.id) > -1) {
      //   score++;
      // }
      scores[command.id] = score;
      matches.push(command);
      if (score > maxScore) maxScore = score;
    }
  }

  for (var m = 0; m < matches.length; m++) {
    if (scores[matches[m].id] >= maxScore / 2) matchedCommands.push(matches[m]);
  }

  // sort the matches by score
  matchedCommands.sort(function (a, b) {
    return scores[b.id] - scores[a.id];
  });

  return matchedCommands;
}

/**
 * Present File.openDialog() for user to select files to load.
 * @param   {String}  prompt        Prompt for dialog.
 * @param   {Boolean} multiselect   Can multiple files be selected.
 * @param   {String}  fileTypeRegex RegEx search string for file types (e.g. ".jsx$|.js$").
 * @returns {Array}                 Selected file(s).
 */
function loadFileTypes(prompt, multiselect, fileTypeRegex) {
  var results = [];
  var files = File.openDialog(prompt, "", multiselect);
  if (files) {
    for (var i = 0; i < files.length; i++) {
      f = files[i];
      fname = decodeURI(f.name);
      if (f.name.search(fileTypeRegex) >= 0) {
        results.push(f);
      }
    }
  }
  return results;
}

/**
 * Simulate a key press for Windows users.
 *
 * This function is in response to a known ScriptUI bug on Windows.
 * You can read more about it in the GitHub issue linked below.
 * https://github.com/joshbduncan/AiCommandPalette/issues/8
 *
 * Basically, on some Windows Ai versions, when a ScriptUI dialog is
 * presented and the active attribute is set to true on a field, Windows
 * will flash the Windows Explorer app quickly and then bring Ai back
 * in focus with the dialog front and center. This is a terrible user
 * experience so Sergey and I attempted to fix it the best we could.
 *
 * This clever solution was created by Sergey Osokin (https://github.com/creold)
 *
 * @param {String} k Key to simulate.
 * @param {Number} n Number of times to simulate the keypress.
 */
function simulateKeypress(k, n) {
  if (!n) n = 1;
  try {
    var f = setupFileObject(settingsFolder, "SimulateKeypress.vbs");
    if (!f.exists) {
      var data = 'Set WshShell = WScript.CreateObject("WScript.Shell")\n';
      while (n--) {
        data += 'WshShell.SendKeys "{' + k + '}"\n';
      }
      f.encoding = "UTF-8";
      f.open("w");
      f.write(data);
      f.close();
    }
    f.execute();
  } catch (e) {
    $.writeln(e);
  }
}

/**
 * Open a url in the system browser.
 * @param {String} url URL to open.
 */
function openURL(url) {
  var html = new File(Folder.temp.absoluteURI + "/aisLink.html");
  html.open("w");
  var htmlBody =
    '<html><head><META HTTP-EQUIV=Refresh CONTENT="0; URL=' +
    url +
    '"></head><body> <p></body></html>';
  html.write(htmlBody);
  html.close();
  html.execute();
}
