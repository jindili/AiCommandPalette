/**
 *
 * @returns Make sure at least one document is open for certain built-in commands.
 */
function activeDocument() {
  if (app.documents.length < 1) {
    alert(localize(locStrings.no_active_document));
    return false;
  }
  return true;
}

/**
 * Get every font used inside of an the Ai document.
 * @param {Object} doc Ai document.
 */
function getDocumentFonts(doc) {
  var fonts = [];
  for (var i = 0; i < doc.textFrames.length; i++) {
    for (var j = 0; j < doc.textFrames[i].textRanges.length; j++) {
      if (!fonts.includes(doc.textFrames[i].textRanges[j].textFont)) {
        fonts.push(doc.textFrames[i].textRanges[j].textFont);
      }
    }
  }
  return fonts;
}

/**
 * Convert Ai points unit to another api ruler constant.
 * https://ai-scripting.docsforadobe.dev/jsobjref/scripting-constants.html#jsobjref-scripting-constants-rulerunits
 * @param   {Number} points Point value to convert.
 * @param   {String} unit   RulerUnit to convert `points` to.
 * @returns {Number}        Converted number.
 */
function convertPointsTo(points, unit) {
  var conversions = {
    Centimeters: 28.346,
    Qs: 0.709,
    Inches: 72.0,
    Pixels: 1.0,
    Millimeters: 2.834645,
    Unknown: 1.0,
    Picas: 12.0,
    Points: 1.0,
  };
  return points / conversions[unit];
}

function getPlacedFileInfoForReport() {
  if (ExternalObject.AdobeXMPScript == undefined)
    ExternalObject.AdobeXMPScript = new ExternalObject("lib:AdobeXMPScript");
  //Read xmp string - You can see document XMP in Illustrator -> File-> File Info -> Raw Data
  var xmp = new XMPMeta(app.activeDocument.XMPString);

  var names = [];
  var allFilePaths = getAllPlacedFilePaths(xmp);
  // var brokenFilePaths = getBrokenFilePaths(xmp);

  // convert path to file object for property access
  var fileObjects = [];
  for (var i = 0; i < allFilePaths.length; i++) {
    fileObjects.push(new File(allFilePaths[i]));
  }
  // sort the files by name
  fileObjects.sort(function (a, b) {
    return a.name - b.name;
  });
  // build string with file info for the report
  var f;
  for (var i = 0; i < fileObjects.length; i++) {
    f = fileObjects[i];
    names.push(
      localize(locStrings.dr_name) +
        decodeURI(f.name) +
        "\n" +
        localize(locStrings.dr_path) +
        f.fsName.replace(f.name, "") +
        "\n" +
        localize(locStrings.dr_file_found) +
        f.exists.toString().toUpperCase() +
        (i == fileObjects.length - 1 ? "" : "\n")
    );
  }
  return names;
}

/**
 * Great trick to get all placed files (linked and embeded) @pixxxelschubser
 * https://community.adobe.com/t5/user/viewprofilepage/user-id/7720512
 *
 * If you try to do this using the placedItems collection from the API you will have issues.
 */
function getAllPlacedFilePaths(xmp) {
  //Read file paths from XMP - this returns file paths of both embedded and linked images
  var paths = [];
  var xpath;
  for (var i = 1; i <= xmp.countArrayItems(XMPConst.NS_XMP_MM, "Manifest"); i++) {
    xpath = "xmpMM:Manifest[" + i + "]/stMfs:reference/stRef:filePath";
    paths.push(xmp.getProperty(XMPConst.NS_XMP_MM, xpath).value);
  }
  return paths;
}

/**
 * Get placed files with broken links.
 */
function getBrokenFilePaths(xmp) {
  //Read file paths from XMP - this returns file paths of both embedded and linked images
  var paths = [];
  var xpath;
  for (var i = 1; i <= xmp.countArrayItems(XMPConst.NS_XMP_MM, "Ingredients"); i++) {
    xpath = "xmpMM:Ingredients[" + i + "]/stRef:filePath";
    paths.push(xmp.getProperty(XMPConst.NS_XMP_MM, xpath).value);
  }
  return paths;
}

/**
 * Return the names of each object in an Ai collection object.
 * https://ai-scripting.docsforadobe.dev/scripting/workingWithObjects.html?highlight=collection#collection-objects
 * @param   {Object} o Ai collection object.
 * @returns {Array}    Array containing each object name.
 */
function getCollectionObjectNames(c, sorted) {
  sorted = typeof sorted !== "undefined" ? sorted : false;
  names = [];
  var s;
  if (c.length > 0) {
    for (var i = 0; i < c.length; i++) {
      if (c.typename == "Spots") {
        if (c[i].name != "[Registration]") {
          names.push(c[i].name);
        }
      } else {
        names.push(c[i].name);
      }
    }
  }
  return sorted ? names.sort() : names;
}

/**
 * Return recently opened files as file objects (also found in File > Open Recent Files).
 * @returns {Array} Recent file paths.
 */
function getRecentFilePaths() {
  var path;
  var paths = [];
  var fileCount = app.preferences.getIntegerPreference("RecentFileNumber");
  for (var i = 0; i < fileCount; i++) {
    path = app.preferences.getStringPreference(
      "plugin/MixedFileList/file" + i + "/path"
    );
    paths.push(path);
  }
  return paths;
}

/**************************************************
DIALOG HELPER FUNCTIONS
**************************************************/

function filterCommands(
  commands,
  queryFilter,
  visibleFilter,
  showHidden,
  hideCommands,
  docRequired,
  selRequired
) {
  var query = [];
  var visible = [];
  var command;
  for (var i = 0; i < commands.length; i++) {
    command = commands[i];
    commandData = commandsData[command];
    // hide commands requiring an active documents if requested
    if (docRequired && !appDocuments && commandData.docRequired) continue;
    // hide commands requiring an active selection if requested
    if (selRequired && !docSelection && commandData.selRequired) continue;
    // make sure Ai version meets command requirements
    if (!versionCheck(command)) continue;
    // skip any hidden commands
    if (!showHidden && data.settings.hidden.includes(command)) continue;
    // skip any specific commands name in hideSpecificCommands
    if (hideCommands.includes(command)) continue;
    // then check to see if the command should be filtered out
    if (!queryFilter.includes(commandData.type)) query.push(command);
    if (!visibleFilter.includes(commandData.type)) visible.push(command);
  }
  return {
    query: query,
    visible: visible,
  };
}

/**
 * Score array items based on regex string match.
 * @param   {String} q   String to search for.
 * @param   {Array}  arr String items to search for.
 * @returns {Array}      Matching items sorted by score.
 */
function scoreMatches(q, arr) {
  var word;
  var words = [];
  var matches = [];
  var words = q.split(" ");
  for (var i = 0; i < arr.length; i++) {
    var score = 0;
    for (var n = 0; n < words.length; n++) {
      word = words[n];
      if (word != "" && arr[i].match("(?:^|\\s)(" + word + ")", "gi") != null)
        score += word.length;
    }
    if (score > 0) matches.push({ command: arr[i], score: score });
  }
  // sort the matches by score
  matches.sort(function (a, b) {
    return b.score - a.score;
  });
  // only return highest scoring matches
  var matchedCommands = [];
  var maxLength = 0;
  for (var i = 0; i < matches.length; i++) {
    if (matches[i].score >= matches[0].score) {
      matchedCommands.push(matches[i].command);
      if (matches[i].command.length > maxLength) maxLength = matches[i].command.length;
    }
  }
  // script ui seem to incorrectly calculate the `itemSize` length when
  // filtering a temp list which the truncates some of the item so this
  // adds a string of "X" the to the end of the result as long as the
  // longest match which can then be removed after the listbox is created
  var str = new Array(maxLength + 1).join("X");
  matchedCommands.push(str);
  return matchedCommands;
}

/**
 * Score array items based on regex string match.
 * @param   {String} q    String to search for.
 * @param   {Array}  arr  Array of object to search through.
 * @param   {String} prop Object property to match on.
 * @returns {Array}       Matching items sorted by score.
 */
function scoreObjectMatches(q, arr, prop) {
  var word;
  var words = q.split(" ");
  var matches = [];
  for (var i = 0; i < arr.length; i++) {
    var score = 0;
    for (var n = 0; n < words.length; n++) {
      word = words[n];
      if (!arr[i].hasOwnProperty(prop)) continue;
      if (word != "" && arr[i][prop].match("(?:^|\\s)(" + word + ")", "gi") != null)
        score++;
    }
    if (score > 0) {
      arr[i].score = score;
      matches.push(arr[i]);
    }
  }
  // sort all matches by score
  matches.sort(function (a, b) {
    return a.score.localeCompare(b.score);
  });
  return matches;
}

function dynamicSort(property) {
  var sortOrder = 1;
  if (property[0] === "-") {
    sortOrder = -1;
    property = property.substr(1);
  }
  return function (a, b) {
    var result = a[property] < b[property] ? -1 : a[property] > b[property] ? 1 : 0;
    return result * sortOrder;
  };
}

/**
 * Simulate a key press for Windows users.
 *
 * This function is in response to a known ScriptUI bug on Windows.
 * You can read more about it in the GitHub issue linked below.
 * https://github.com/joshbduncan/AiCommandPalette/issues/8
 *
 * Basically, on some Windows Ai versions, when a ScriptUI dialog is
 * presented and the active attribute is set to true on a field, Windows
 * will flash the Windows Explorer app quickly and then bring Ai back
 * in focus with the dialog front and center. This is a terrible user
 * experience so Sergey and I attempted to fix it the best we could.
 *
 * This clever solution was created by Sergey Osokin (https://github.com/creold)
 *
 * @param {String} k Key to simulate.
 * @param {Number} n Number of times to simulate the keypress.
 */
function simulateKeypress(k, n) {
  if (!n) n = 1;
  try {
    var f = setupFileObject(settingsFolder, "SimulateKeypress.vbs");
    if (!f.exists) {
      var data = 'Set WshShell = WScript.CreateObject("WScript.Shell")\n';
      while (n--) {
        data += 'WshShell.SendKeys "{' + k + '}"\n';
      }
      f.encoding = "UTF-8";
      f.open("w");
      f.write(data);
      f.close();
    }
    f.execute();
  } catch (e) {
    $.writeln(e);
  }
}

/**
 * Open a url in the system browser.
 * @param {String} url URL to open.
 */
function openURL(url) {
  var html = new File(Folder.temp.absoluteURI + "/aisLink.html");
  html.open("w");
  var htmlBody =
    '<html><head><META HTTP-EQUIV=Refresh CONTENT="0; URL=' +
    url +
    '"></head><body> <p></body></html>';
  html.write(htmlBody);
  html.close();
  html.execute();
}
