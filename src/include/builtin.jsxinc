// AI COMMAND PALETTE OPERATIONS

/**
 * Execute script actions.
 * @param {Object} action Script action to execute.
 */
function scriptAction(action) {
  var write = true;
  switch (action) {
    case "settings":
      paletteSettings();
      write = false;
      break;
    case "about":
      about();
      write = false;
      break;
    case "buildWorkflow":
      buildWorkflow();
      break;
    case "editWorkflow":
      editWorkflow();
      break;
    case "loadScript":
      loadScripts();
      break;
    case "runAction":
      runAction();
      break;
    case "hideCommand":
      hideCommand();
      break;
    case "unhideCommand":
      unhideCommand();
      break;
    case "deleteCommand":
      deleteCommand();
      break;
    case "revealPrefFile":
      settings.reveal();
      write = false;
      break;
    default:
      alert(localize(locStrings.cd_invalid, action));
  }
  if (write) settings.save();
}

/**
 * Execute built-in actions.
 * @param {Object} action Built-in action to execute.
 */
function builtinAction(action) {
  switch (action) {
    case "documentReport":
      if (activeDocument) documentReport();
      break;
    case "redrawWindows":
      app.redraw();
      break;
    case "revealActiveDocument":
      if (activeDocument) {
        if (app.activeDocument.path.fsName) {
          var fp = new Folder(app.activeDocument.path.fsName);
          fp.execute();
        } else {
          alert(localize(locStrings.active_document_not_saved));
        }
      }
      break;
    case "goToArtboard":
      if (activeDocument) goToArtboard();
      break;
    case "goToNamedObject":
      if (activeDocument) goToNamedObject();
      break;
    default:
      alert(localize(locStrings.cd_invalid, action));
  }
}

/** Ai Command Palette configuration commands. */
function paletteSettings() {
  var result = commandPalette(
    (commands = allCommands),
    (showHidden = false),
    (queryFilter = [
      "builtin",
      "script",
      "workflow",
      "defaults",
      "action",
      "menu",
      "tool",
    ]),
    (visibleFilter = []),
    (title = localize(locStrings.cp_config)),
    (bounds = [0, 0, paletteWidth, 182]),
    (multiselect = false)
  );
  if (result) processCommand(result);
}

/** Ai Command Palette About Dialog. */
function about() {
  var win = new Window("dialog");
  win.text = localize(locStrings.about);
  win.alignChildren = "fill";

  // script info
  var pAbout = win.add("panel");
  pAbout.margins = 20;
  pAbout.alignChildren = "fill";
  pAbout.add("statictext", [0, 0, 500, 100], localize(locStrings.description), {
    multiline: true,
  });

  var links = pAbout.add("group");
  links.orientation = "column";
  links.alignChildren = ["center", "center"];
  links.add("statictext", undefined, localize(locStrings.version, _version));
  links.add("statictext", undefined, localize(locStrings.copyright));
  var githubText =
    localize(locStrings.github) + ": https://github.com/joshbduncan/AiCommandPalette";
  var github = links.add("statictext", undefined, githubText);
  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var ok = winButtons.add("button", undefined, "OK");
  ok.preferredSize.width = 100;

  github.addEventListener("mousedown", function () {
    openURL("https://github.com/joshbduncan/AiCommandPalette");
  });

  win.show();
}

/** Document Info Dialog */
function documentReport() {
  // setup the basic document info
  var rulerUnits = app.activeDocument.rulerUnits.toString().split(".").pop();
  var fileInfo =
    "File Information:\n-----\nFile: " +
    app.activeDocument.name +
    "\nPath: " +
    (app.activeDocument.path.fsName ? app.activeDocument.path.fsName : "None") +
    "\nColor Space: " +
    app.activeDocument.documentColorSpace.toString().split(".").pop() +
    "\nWidth: " +
    convertPointsTo(app.activeDocument.width, rulerUnits) +
    " " +
    rulerUnits +
    "\nHeight: " +
    convertPointsTo(app.activeDocument.height, rulerUnits) +
    " " +
    rulerUnits;

  // generate all optional report information (all included by default)
  var reportOptions = {
    Artboards: {
      str: getCollectionObjectNames(app.activeDocument.artboards)
        .toString()
        .replace(/,/g, "\n"),
      active: true,
    },
    "Embedded Items": {
      str: getCollectionObjectNames(app.activeDocument.rasterItems)
        .toString()
        .replace(/,/g, "\n"),
      active: true,
    },
    Fonts: {
      str: getCollectionObjectNames(getDocumentFonts(app.activeDocument))
        .toString()
        .replace(/,/g, "\n"),
      active: true,
    },
    Layers: {
      str: getCollectionObjectNames(app.activeDocument.layers)
        .toString()
        .replace(/,/g, "\n"),
      active: true,
    },
    "Placed Items": {
      str: getCollectionObjectNames(app.activeDocument.placedItems)
        .toString()
        .replace(/,/g, "\n"),
      active: true,
    },
    "Spot Colors": {
      str: getCollectionObjectNames(app.activeDocument.spots)
        .toString()
        .replace(/,/g, "\n"),
      active: true,
    },
  };

  // build the report from the selected options (active = true)
  function buildReport() {
    var infoString = "Ai Document Information\n\n" + fileInfo;
    for (var p in reportOptions) {
      if (reportOptions[p].active && reportOptions[p].str) {
        infoString += "\n\n" + p + "\n-----\n" + reportOptions[p].str;
      }
    }
    infoString += "\n\nFile Created: " + new Date();
    return infoString;
  }

  // setup the dialog
  var win = new Window("dialog");
  win.text = localize(locStrings.document_report);
  win.orientation = "column";
  win.alignChildren = ["center", "top"];
  win.alignChildren = "fill";

  // panel - options
  var pOptions = win.add("panel", undefined, "Include?");
  pOptions.orientation = "row";
  pOptions.margins = 20;

  // add checkboxes for each report option
  var cb;
  for (var p in reportOptions) {
    cb = pOptions.add("checkbox", undefined, p);
    if (reportOptions[p].str) {
      cb.value = true;
      // add onClick function for each cb to update rebuild report
      cb.onClick = function () {
        if (this.value) {
          reportOptions[this.text].active = true;
        } else {
          reportOptions[this.text].active = false;
        }
        info.text = buildReport();
      };
    } else {
      cb.value = false;
      cb.enabled = false;
    }
  }

  // script info
  var info = win.add("edittext", [0, 0, 400, 400], buildReport(), {
    multiline: true,
    scrollable: true,
    readonly: true,
  }); // TODO: localize

  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var saveInfo = winButtons.add("button", undefined, "Save Info");
  saveInfo.preferredSize.width = 100;
  var close = winButtons.add("button", undefined, "Close", { name: "ok" }); // TODO: localize
  close.preferredSize.width = 100;

  // save document info to selected file
  saveInfo.onClick = function () {
    var f = File.saveDialog();
    if (f) {
      try {
        f.encoding = "UTF-8";
        f.open("w");
        f.write(infoString);
        f.close();
      } catch (e) {
        alert(localize(locStrings.fl_error_writing, f));
      }
      if (f.exists) alert("File Saved\n" + f.fsName); // TODO: localize
    }
  };
  // show the info dialog
  win.show();
}

/** Load external scripts into Ai Command Palette. */
function loadScripts() {
  var files = loadFileTypes(
    localize(locStrings.cp_config_load_scripts),
    true,
    ".jsx$|.js$"
  );
  if (files.length > 0) {
    var f, key, fname;
    for (var i = 0; i < files.length; i++) {
      f = files[i];
      fname = decodeURI(f.name);
      key = localize(locStrings.script) + ": " + fname;
      if (data.commands.script.hasOwnProperty(key)) {
        if (
          !Window.confirm(
            localize(locStrings.sc_already_loaded),
            "noAsDflt",
            localize(locStrings.sc_already_loaded_title)
          )
        )
          continue;
      }
      try {
        data.commands.script[key] = { name: fname, type: "script", path: f.fsName };
      } catch (e) {
        alert(localize(locStrings.sc_error_loading, f.fsName));
      }
    }
  } else {
    alert(localize(locStrings.sc_none_selected));
  }
}

/** Hide commands from Ai Command Palette. */
function hideCommand() {
  var result = commandPalette(
    (commands = allCommands),
    (showHidden = false),
    (queryFilter = ["config", "defaults"]),
    (visibleFilter = []),
    (title = localize(locStrings.cd_hide_select)),
    (bounds = [0, 0, paletteWidth, 182]),
    (multiselect = true)
  );
  if (result) {
    for (var i = 0; i < result.length; i++) data.settings.hidden.push(result[i].text);
  }
}

/** Unhide hidden commands. */
function unhideCommand() {
  if (data.settings.hidden.length > 0) {
    var result = commandPalette(
      (commands = data.settings.hidden),
      (showHidden = true),
      (queryFilter = []),
      (visibleFilter = []),
      (title = localize(locStrings.cd_reveal_menu_select)),
      (bounds = [0, 0, paletteWidth, 182]),
      (multiselect = true)
    );
    if (result) {
      for (var i = 0; i < result.length; i++) {
        for (var n = 0; n < data.settings.hidden.length; n++) {
          if (result[i].text == data.settings.hidden[n]) {
            data.settings.hidden.splice(n, 1);
          }
        }
      }
    }
  } else {
    alert(localize(logStrings.cd_none_reveal));
  }
}

/** Delete commands from Ai Command Palette. */
function deleteCommand() {
  var result = commandPalette(
    (commands = allCommands),
    (showHidden = true),
    (queryFilter = ["action", "builtin", "config", "defaults", "menu", "tool"]),
    (visibleFilter = []),
    (title = localize(locStrings.cd_delete_select)),
    (bounds = [0, 0, paletteWidth, 182]),
    (multiselect = true)
  );
  if (result) {
    if (
      Window.confirm(
        localize(locStrings.cd_delete_confirm, result.join("\n")),
        "noAsDflt",
        localize(locStrings.cd_delete_confirm_title)
      )
    ) {
      var command, type;
      for (var i = 0; i < result.length; i++) {
        command = result[i].text;
        type = commandsData[command].type;
        try {
          delete data.commands[type][command];
        } catch (e) {
          alert(localize(locStrings.cd_error_delete, command));
        }
      }
    }
  }
}

// BUILT-IN COMMANDS

/** Present a command palette with all artboards then zoom to the chosen artboard. */
function goToArtboard() {
  var artboards = [];
  for (var i = 0; i < app.activeDocument.artboards.length; i++) {
    artboards.push(app.activeDocument.artboards[i]);
  }

  var item = goToPalette(
    (commands = artboards),
    (title = localize(locStrings["go_to_artboard"])),
    (bounds = [0, 0, paletteWidth, 182])
  );
  if (item) {
    var ab;
    for (var i = 0; i < app.activeDocument.artboards.length; i++) {
      ab = app.activeDocument.artboards[i];
      if (ab.name == item.name) {
        app.activeDocument.artboards.setActiveArtboardIndex(i);
        app.executeMenuCommand("fitin");
        break;
      }
    }
  }
}

/** Present a command palette with all named objects zoom to and select the chosen object. */
function goToNamedObject() {
  if (app.activeDocument.pageItems.length > namedObjectLimit)
    alert(
      localize(locStrings.go_to_named_object_limit, app.activeDocument.pageItems.length)
    );
  var namedObjects = [];
  var item;
  for (var i = 0; i < app.activeDocument.pageItems.length; i++) {
    item = app.activeDocument.pageItems[i];
    if (
      item.name ||
      item.name.length ||
      item.typename == "PlacedItem" ||
      item.typename == "SymbolItem"
    )
      namedObjects.push(item);
  }
  if (namedObjects.length) {
    var selectedObject = goToPalette(
      (commands = namedObjects),
      (title = localize(locStrings["goto_named_object"])),
      (bounds = [0, 0, paletteWidth, 182])
    );
    if (selectedObject) {
      app.activeDocument.selection = null;
      selectedObject.selected = true;

      // reset zoom for current document
      app.activeDocument.views[0].zoom = 1;

      // get screen information
      var screenBounds = app.activeDocument.views[0].bounds;
      var screenW = screenBounds[2] - screenBounds[0];
      var screenH = screenBounds[1] - screenBounds[3];

      // get the (true) visible bounds of the returned object
      var bounds = selectedObject.visibleBounds;
      var selectedObjectW = bounds[2] - bounds[0];
      var selectedObjectH = bounds[1] - bounds[3];
      var selectedObjectCX = bounds[0] + selectedObjectW / 2;
      var selectedObjectCY = bounds[1] - selectedObjectH / 2;

      // reset the current view to center of selected object
      doc.views[0].centerPoint = [selectedObjectCX, selectedObjectCY];

      // calculate new zoom ratio to fit view to selected object
      var zoomRatio;
      if (selectedObjectW * (screenH / screenW) >= selectedObjectH) {
        zoomRatio = screenW / selectedObjectW;
      } else {
        zoomRatio = screenH / selectedObjectH;
      }

      // set zoom to fit selected object plus a bit of padding
      var padding = 0.9;
      doc.views[0].zoom = zoomRatio * padding;
    }
  } else {
    alert(localize(locStrings.go_to_named_object_no_objects));
  }
}
