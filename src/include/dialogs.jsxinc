// CUSTOM SCRIPTUI LISTBOX

function ListBoxWrapper(commands, win, multiselect) {
  this.listbox = this.make(commands, win, paletteSettings.bounds, multiselect);
}

ListBoxWrapper.prototype = {
  make: function (commands, win, bounds, multiselect) {
    listbox = win.add("listbox", bounds, undefined, {
      numberOfColumns: paletteSettings.listboxProperties.numberOfColumns,
      showHeaders: paletteSettings.listboxProperties.showHeaders,
      columnTitles: paletteSettings.listboxProperties.columnTitles,
      columnWidths: paletteSettings.listboxProperties.columnWidths,
      multiselect: multiselect,
    });
    this.loadCommands(listbox, commands);
    this.addListeners(listbox);
    listbox.frameStart = 0;
    listbox.selection = 0;
    return listbox;
  },
  update: function (matches) {
    temp = this.make(
      matches,
      this.listbox.window,
      this.listbox.bounds,
      this.listbox.properties.multiselect
    );
    this.listbox.window.remove(this.listbox);
    this.listbox = temp;
  },
  loadCommands: function (lb, commands) {
    var command;
    for (var i = 0; i < commands.length; i++) {
      command = commands[i];
      with (lb.add("item", command.name)) {
        subItems[0].text = command.type; // TODO: add localization
      }
    }
  },
  addListeners: function (lb) {
    selectOnDoubleClick(lb);
    if (!lb.properties.multiselect) {
      scrollListBoxWithArrows(lb);
    }
  },
};

// LISTBOXWRAPPER LISTENERS

/**
 * Close listbox when double-clicking a command.
 * @param {Object}  lb  ScriptUI listbox.
 */
function selectOnDoubleClick(lb) {
  lb.onDoubleClick = function () {
    if (lb.selection) lb.window.close(1);
  };
}

/**
 * Allow end-to-end scrolling from within a listbox.
 * @param {Object}  lb  ScriptUI listbox.
 */
function scrollListBoxWithArrows(lb) {
  lb.addEventListener("keydown", function (e) {
    if (e.fromQuery) {
      if (e.fromQueryShiftKey) {
        if (e.keyName == "Up") {
          if (this.selection.index == 0) {
            this.selection = this.items.length - 1;
            e.preventDefault();
          } else {
            this.selection--;
          }
        }
        if (e.keyName == "Down") {
          if (this.selection.index == this.items.length - 1) {
            this.selection = 0;
            e.preventDefault();
          } else {
            if (e.keyName == "Down") this.selection++;
          }
        }
      } else {
        if (e.keyName == "Up" || e.keyName == "Down") {
          if (e.keyName == "Up") {
            e.preventDefault();
            if (!this.selection) {
              this.selection = 0;
            } else if (this.selection.index == 0) {
              // jump to the bottom if at top
              this.selection = this.items.length - 1;
              this.frameStart = this.items.length - 1 - visibleListItems;
            } else {
              if (this.selection.index > 0) {
                this.selection = this.selection.index - 1;
                if (this.selection.index < this.frameStart) this.frameStart--;
              }
            }
          } else if (e.keyName == "Down") {
            e.preventDefault();
            if (!this.selection) {
              this.selection = 0;
            } else if (this.selection.index === this.items.length - 1) {
              // jump to the top if at the bottom
              this.selection = 0;
              this.frameStart = 0;
            } else {
              if (this.selection.index < this.items.length) {
                this.selection = this.selection.index + 1;
                if (this.selection.index > this.frameStart + visibleListItems - 1) {
                  if (this.frameStart < this.items.length - visibleListItems) {
                    this.frameStart++;
                  } else {
                    this.frameStart = this.frameStart;
                  }
                }
              }
            }
          }
          /*
        If a selection is made inside of the actual listbox frame by the user,
        the API doesn't offer any way to know which part of the list is currently
        visible in the listbox "frame". If the user was to re-enter the `q` edittext
        and then hit an arrow key the above event listener will not work correctly so
        I just move the next selection (be it up or down) to the middle of the "frame".
        */
          if (this.selection) {
            if (
              this.selection.index < this.frameStart ||
              this.selection.index > this.frameStart + visibleListItems - 1
            )
              this.frameStart = this.selection.index - Math.floor(visibleListItems / 2);
            // don't move the frame if list items don't fill the available rows
            if (this.items.length <= visibleListItems) return;
            // move the frame by revealing the calculated `this.frameStart`
            this.revealItem(this.frameStart);
          }
        }
      }
    } else {
      if (e.keyName == "Up" && this.selection.index == 0) {
        this.selection = this.items.length - 1;
        e.preventDefault();
      }
      if (e.keyName == "Down" && this.selection.index == this.items.length - 1) {
        this.selection = 0;
        e.preventDefault();
      }
    }
  });
}

// USER DIALOGS

function commandPalette(commands, title, multiselect, showOnly) {
  // create the dialog
  var win = new Window("dialog");
  win.text = title;
  win.alignChildren = "fill";

  // setup the query input
  var q = win.add("edittext");
  q.helpTip = localize(locStrings.cd_q_helptip);

  // setup the commands listbox
  var list = new ListBoxWrapper(
    showOnly ? showOnly : commands,
    win,
    multiselect,
    showOnly
  );

  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var ok = winButtons.add("button", undefined, "OK");
  ok.preferredSize.width = 100;
  var cancel = winButtons.add("button", undefined, localize(locStrings.cancel), {
    name: "cancel",
  });
  cancel.preferredSize.width = 100;

  // work-around to stop windows from flickering/flashing explorer
  if (windowsFlickerFix) {
    simulateKeypress("TAB", 1);
  } else {
    q.active = true;
  }

  // as a query is typed update the listbox
  var matches;
  q.onChanging = function () {
    if (this.text === "") {
      matches = showOnly ? showOnly : commands;
    } else {
      matches = scoreMatches(this.text, commands);
    }
    if (matches.length > 0) {
      list.update(matches);
    }
  };

  // allow using arrow key from query input
  var kbEvent = ScriptUI.events.createEvent("KeyboardEvent");
  q.addEventListener("keydown", function (e) {
    if (e.keyName == "Up" || e.keyName == "Down") {
      kbEvent.initKeyboardEvent("keydown", true, true, list.listbox, e.keyName, 0, "");
      kbEvent.fromQuery = true;
      kbEvent.fromQueryShiftKey = e.getModifierState("shift");
      list.listbox.dispatchEvent(kbEvent);
      e.preventDefault();
    }
  });

  if (win.show() == 1) {
    if (list.listbox.selection) {
      return multiselect ? list.listbox.selection : [list.listbox.selection];
    }
  }
  return false;
}

function goToPalette(commands, title) {
  // copy the commands
  var matches = commands;

  // create the dialog
  var win = new Window("dialog");
  win.text = title;
  win.alignChildren = "fill";
  var q = win.add("edittext");
  q.helpTip = localize(locStrings.cd_q_helptip);

  // work-around to stop windows from flickering/flashing explorer
  if (windowsFlickerFix) {
    simulateKeypress("TAB", 1);
  } else {
    q.active = true;
  }

  // setup the commands listbox
  var list = win.add(
    "listbox",
    paletteSettings.bounds,
    [],
    paletteSettings.listboxProperties
  );

  // add items to list
  for (var i = 0; i < matches.length; i++) {
    switch (matches[i].typename) {
      case "Document":
        var colormode =
          "(" + matches[i].documentColorSpace.toString().split(".").pop() + ")";
        matches[i]["queryName"] =
          matches[i] == app.activeDocument
            ? "x " + matches[i].name + " " + colormode
            : "   " + matches[i].name + " " + colormode;
        break;
      case "PlacedItem":
        matches[i]["queryName"] = matches[i].file.name;
        break;
      case "SymbolItem":
        matches[i]["queryName"] =
          matches[i].name || matches[i].name.length
            ? matches[i].name
            : matches[i].symbol.name;
        break;
      default:
        matches[i]["queryName"] = matches[i].name;
        break;
    }
    with (list.add("Item", truncateCommandName(matches[i].queryName, 50))) {
      subItems[0].text = matches[i].typename;
    }
  }
  list.selection = 0;

  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var ok = winButtons.add("button", undefined, "OK");
  ok.preferredSize.width = 100;
  var cancel = winButtons.add("button", undefined, localize(locStrings.cancel), {
    name: "cancel",
  });
  cancel.preferredSize.width = 100;

  // as a query is typed update the list box
  var matches, temp;
  q.onChanging = function () {
    list.frameStart = 0;
    matches =
      this.text === "" ? commands : scoreObjectMatches(this.text, matches, "queryName");
    if (matches.length > 0) {
      var temp = win.add("listbox", list.bounds, [], {
        numberOfColumns: list.properties.numberOfColumns,
        showHeaders: list.properties.showHeaders,
        columnTitles: list.properties.columnTitles,
        columnWidths: list.properties.columnWidths,
      });

      for (var i = 0; i < matches.length; i++) {
        with (temp.add("Item", truncateCommandName(matches[i].queryName, 50))) {
          subItems[0].text = matches[i].typename;
        }
      }
      // close window when double-clicking a selection
      temp.onDoubleClick = function () {
        if (list.selection) win.close(1);
      };

      // if (!multiselect) scrollListBox(list);

      // remove the temp 'truncation fix' item from the list
      if (matches != commands.visible) temp.remove(temp.items.length - 1);
      win.remove(list);
      list = temp;
      list.selection = 0;
    }
  };

  // scrollListBox(list);

  if (list.items.length > 0) {
    /*
    Move the listbox frame of visible items when using the
    up and down arrow keys while in the `q` edittext.

    One problem with this functionality is that when a listbox listitem
    is selected via a script the API moves the visible "frame" of items
    so that the new selection is at the top. This is not standard behavior,
    and not even how the listbox behaves when you use the up and down keys inside
    of the actual listbox.

    Only works if multiselect if set to false.
    */
    q.addEventListener("keydown", function (k) {
      if (k.keyName == "Up" || k.keyName == "Down") {
        if (k.keyName == "Up") {
          k.preventDefault();
          if (!list.selection) {
            list.selection = 0;
          } else if (list.selection.index == 0) {
            // jump to the bottom if at top
            list.selection = list.items.length - 1;
            list.frameStart = list.items.length - 1 - visibleListItems;
          } else {
            if (list.selection.index > 0) {
              list.selection = list.selection.index - 1;
              if (list.selection.index < list.frameStart) list.frameStart--;
            }
          }
        } else if (k.keyName == "Down") {
          k.preventDefault();
          if (!list.selection) {
            list.selection = 0;
          } else if (list.selection.index === list.items.length - 1) {
            // jump to the top if at the bottom
            list.selection = 0;
            list.frameStart = 0;
          } else {
            if (list.selection.index < list.items.length) {
              list.selection = list.selection.index + 1;
              if (list.selection.index > list.frameStart + visibleListItems - 1) {
                if (list.frameStart < list.items.length - visibleListItems) {
                  list.frameStart++;
                } else {
                  list.frameStart = list.frameStart;
                }
              }
            }
          }
        }
        /*
      If a selection is made inside of the actual listbox frame by the user,
      the API doesn't offer any way to know which part of the list is currently
      visible in the listbox "frame". If the user was to re-enter the `q` edittext
      and then hit an arrow key the above event listener will not work correctly so
      I just move the next selection (be it up or down) to the middle of the "frame".
      */
        if (list.selection) {
          if (
            list.selection.index < list.frameStart ||
            list.selection.index > list.frameStart + visibleListItems - 1
          )
            list.frameStart = list.selection.index - Math.floor(visibleListItems / 2);
          // don't move the frame if list items don't fill the available rows
          if (list.items.length <= visibleListItems) return;
          // move the frame by revealing the calculated `list.frameStart`
          list.revealItem(list.frameStart);
        }
      }
    });
  }

  function truncateCommandName(s, n) {
    return s.length <= n ? s : s.slice(0, n) + "...";
  }

  // close window when double-clicking a selection
  list.onDoubleClick = function () {
    if (list.selection) win.close(1);
  };

  if (win.show() == 1) {
    if (list.selection) {
      return matches[list.selection.index];
    }
  }
  return false;
}

/**
 * Show the workflow builder with a filterable listbox.
 * @param   {Array}    commands      Commands available to the palette.
 * @param   {Array}    queryFilter   Types of commands to hide from the search query.
 * @param   {String}   edit          Name of a current workflow to edit (if any).
 * @returns {Array}                  Array of selected list items.
 */
function workflowBuilder(commands, queryFilter, edit) {
  // insert command and type into listbox
  function insertCommands(list, commands) {
    var command, commandData;
    for (var i = 0; i < commands.length; i++) {
      command = commands[i];
      commandData = commandsData[localizedCommandLookup[command]];
      with (list.add("item", command)) {
        subItems[0].text = commandData.type; // TODO: add localization
      }
    }
  }

  // if editing a command, pull in variables to prefill dialog with
  var command;
  var actions = [];
  var hideCommands = [];
  if (edit != undefined) {
    command = commandsData[localizedCommandLookup[edit]];
    for (var i = 0; i < command.actions.length; i++) {
      actions.push(idCommandLookup[command.actions[i]]);
    }
    // make sure workflows can't include themselves
    hideCommands.push(edit);
  }

  commands = filterCommands(commands, queryFilter, [], true, [], false, false);

  // create the dialog
  var win = new Window("dialog");
  win.text = localize(locStrings.wf_builder);
  win.alignChildren = "fill";

  // command search
  var pSearch = win.add("panel", undefined, localize(locStrings.cd_search_for));
  pSearch.alignChildren = ["fill", "center"];
  pSearch.margins = 20;
  var q = pSearch.add("edittext");
  q.helpTip = localize(locStrings.cd_q_helptip);

  // work-around to stop windows from flickering/flashing explorer
  if (windowsFlickerFix) {
    simulateKeypress("TAB", 1);
  } else {
    q.active = true;
  }

  var list = pSearch.add(
    "listbox",
    [0, 0, paletteSettings.paletteWidth + 40, paletteSettings.paletteHeight],
    undefined,
    {
      numberOfColumns: paletteSettings.listboxProperties.numberOfColumns,
      showHeaders: paletteSettings.listboxProperties.showHeaders,
      columnTitles: paletteSettings.listboxProperties.columnTitles,
      columnWidths: paletteSettings.listboxProperties.columnWidths,
      multiselect: false,
    }
  );
  list.helpTip = localize(locStrings.cd_helptip);
  insertCommands(list, commands.visible);
  list.selection = 0;

  // add item to workflow step on double-click
  list.onDoubleClick = function () {
    if (list.selection) {
      steps.add("item", list.selection);
      workflowName.enabled = steps.items.length > 0 ? true : false;
      ok.enabled = workflowName.text.length > 0 ? true : false;
    }
  };

  // workflow steps
  var pSteps = win.add("panel", undefined, localize(locStrings.wf_steps));
  pSteps.alignChildren = ["fill", "center"];
  pSteps.margins = 20;
  var steps = pSteps.add(
    "listbox",
    [0, 0, paletteSettings.paletteWidth + 40, paletteSettings.paletteHeight],
    actions,
    {
      multiselect: true,
    }
  );
  steps.helpTip = localize(locStrings.wf_steps_helptip);
  var stepButtons = pSteps.add("group");
  stepButtons.alignment = "center";
  var up = stepButtons.add("button", undefined, localize(locStrings.step_up));
  up.preferredSize.width = 100;
  var down = stepButtons.add("button", undefined, localize(locStrings.step_down));
  down.preferredSize.width = 100;
  var del = stepButtons.add("button", undefined, localize(locStrings.step_delete));
  del.preferredSize.width = 100;

  // command name
  var pName = win.add("panel", undefined, localize(locStrings.wf_save_as));
  pName.alignChildren = ["fill", "center"];
  pName.margins = 20;
  var workflowNameText = edit == undefined ? "" : edit;
  var workflowName = pName.add("edittext", undefined, workflowNameText);
  workflowName.enabled = edit == undefined ? false : true;

  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var ok = winButtons.add("button", undefined, "OK");
  ok.preferredSize.width = 100;
  ok.enabled = edit == undefined ? false : true;
  var cancel = winButtons.add("button", undefined, localize(locStrings.cancel), {
    name: "cancel",
  });
  cancel.preferredSize.width = 100;

  // as a query is typed update the list box
  var matches, temp;
  q.onChanging = function () {
    list.frameStart = 0;
    matches =
      this.text === "" ? commands.visible : scoreMatches(this.text, commands.query);
    if (matches.length > 0) {
      // setup the temp commands listbox
      temp = pSearch.add("listbox", list.bounds, undefined, {
        numberOfColumns: list.properties.numberOfColumns,
        showHeaders: list.properties.showHeaders,
        columnTitles: list.properties.columnTitles,
        columnWidths: list.properties.columnWidths,
        multiselect: list.properties.multiselect,
      });
      insertCommands(temp, matches);

      // add item to workflow step on double-click
      temp.onDoubleClick = function () {
        if (temp.selection) {
          steps.add("item", temp.selection);
          workflowName.enabled = steps.items.length > 0 ? true : false;
          ok.enabled = workflowName.text.length > 0 ? true : false;
        }
      };

      // change the original listbox reference to the updated `temp` version
      pSearch.remove(list);
      list = temp;

      // reset the selection
      list.selection = 0;
    }
  };

  workflowName.onChanging = function () {
    ok.enabled = workflowName.text.length > 0 ? true : false;
  };

  up.onClick = function () {
    var selected = sortIndexes(steps.selection);
    if (selected[i] == 0 || !contiguous(selected)) return;
    for (var i = 0; i < selected.length; i++)
      swap(steps.items[selected[i] - 1], steps.items[selected[i]]);
    steps.selection = null;
    for (var n = 0; n < selected.length; n++) steps.selection = selected[n] - 1;
  };

  down.onClick = function () {
    var selected = sortIndexes(steps.selection);
    if (
      selected[selected.length - 1] == steps.items.length - 1 ||
      !contiguous(selected)
    )
      return;
    for (var i = steps.selection.length - 1; i > -1; i--)
      swap(steps.items[selected[i]], steps.items[selected[i] + 1]);
    steps.selection = null;
    for (var n = 0; n < selected.length; n++) steps.selection = selected[n] + 1;
  };

  // the api returns the selected items in the order they were
  // selected/clicked by the user when you call `list.selection`
  // so their actual listbox indexes need to be sorted for the
  // up, down, and delete buttons to work when multiple items are selected
  function sortIndexes(sel) {
    var indexes = [];
    for (var i = 0; i < sel.length; i++) indexes.push(sel[i].index);
    return indexes.sort();
  }

  // check to make sure selection is contiguous
  function contiguous(sel) {
    return sel.length == sel[sel.length - 1] - sel[0] + 1;
  }

  /** swap listbox items in place */
  function swap(x, y) {
    var t = x.text;
    x.text = y.text;
    y.text = t;
  }

  del.onClick = function () {
    var selected = sortIndexes(steps.selection);
    for (var i = steps.selection.length - 1; i > -1; i--) {
      steps.remove(selected[i]);
    }
    steps.selection == null;
    workflowName.enabled = steps.items.length > 0 ? true : false;
    ok.enabled = workflowName.text.length > 0 ? true : false;
  };

  if (win.show() == 1) {
    return { name: workflowName.text.trim(), actions: steps.items };
  }
  return false;
}

/**
 * Present File.openDialog() for user to select files to load.
 * @param   {String}  prompt        Prompt for dialog.
 * @param   {Boolean} multiselect   Can multiple files be selected.
 * @param   {String}  fileTypeRegex RegEx search string for file types (e.g. ".jsx$|.js$").
 * @returns {Array}                 Selected file(s).
 */
function loadFileTypes(prompt, multiselect, fileTypeRegex) {
  var results = [];
  var files = File.openDialog(prompt, "", multiselect);
  if (files) {
    for (var i = 0; i < files.length; i++) {
      f = files[i];
      fname = decodeURI(f.name);
      if (f.name.search(fileTypeRegex) >= 0) {
        results.push(f);
      }
    }
  }
  return results;
}

/**
 * close list on double-click of list item
 * @param {Object} listbox ScriptUI ListBox.
 */
function selectOnDoubleClick(listbox) {
  win = listbox.parent;
  listbox.onDoubleClick = function () {
    if (listbox.selection) win.close(1);
  };
}
