// CUSTOM SCRIPTUI FILTERABLE LISTBOX

/**
 * Custom wrapper for a ScriptUI Listbox.
 * @param {Array}   commands    Commands to load into the list box (e.g. [{name: command name, type: command type}]).
 * @param {Object}  win         ScriptUI window the listbox should be attached to.
 * @param {Array}   bounds      Bounds array for the listbox.
 * @param {Boolean} multiselect Should the listbox allow multiple selections (disable some features).
 * @param {String}  helptip     Listbox helptip/tooltip pop-up.
 * @param {Array}   listeners   ScriptUI listeners to add to the listbox.
 */
function ListBoxWrapper(commands, win, bounds, multiselect, helptip, listeners) {
  this.helptip = helptip;
  this.listeners = listeners;
  this.listbox = this.make(commands, win, bounds, multiselect);
}

ListBoxWrapper.prototype = {
  /**
   * Initialize a new ScriptUI listbox, load the initial commands, and attach event listeners.
   * @param {Array} commands Commands to load into the list box (e.g. [{name: command name, type: command type}]).
   * @returns {Object} ScriptUI listbox.
   */
  make: function (commands, win, bounds, multiselect) {
    listbox = win.add("listbox", bounds, undefined, {
      numberOfColumns: paletteSettings.listboxProperties.numberOfColumns,
      showHeaders: paletteSettings.listboxProperties.showHeaders,
      columnTitles: paletteSettings.listboxProperties.columnTitles,
      columnWidths: paletteSettings.listboxProperties.columnWidths,
      multiselect: multiselect,
    });
    this.loadCommands(listbox, commands);
    this.addListeners(listbox);
    if (this.helptip) listbox.helpTip = this.helptip;
    listbox.frameStart = 0;
    listbox.selection = 0;
    return listbox;
  },
  /**
   * Update the listbox with new items.
   * @param {Array} matches New commands to load into the list box (e.g. [{name: command name, type: command type}]).
   */
  update: function (matches) {
    temp = this.make(
      matches,
      this.listbox.window,
      this.listbox.bounds,
      this.listbox.properties.multiselect
    );
    this.listbox.window.remove(this.listbox);
    this.listbox = temp;
  },
  /**
   * Load command items in a ScriptUI listbox.
   * @param {Object} listbox ScriptUI listbox to load the command item in to.
   * @param {Array} commands Commands to load into the list box (e.g. [{name: command name, type: command type}]).
   */
  loadCommands: function (listbox, commands) {
    var command;
    for (var i = 0; i < commands.length; i++) {
      command = commands[i];
      with (listbox.add("item", command.name)) {
        subItems[0].text = command.type;
      }
    }
  },
  /**
   * Attach event listeners to the specified listbox.
   * @param {Object} listbox ScriptUI listbox to attach the listeners to.
   */
  addListeners: function (listbox) {
    var listener;
    for (var i = 0; i < this.listeners.length; i++) {
      listener = this.listeners[i];
      listener(listbox);
    }
  },
};

// LISTBOXWRAPPER LISTENERS

/**
 * Close listbox when double-clicking a command.
 * @param {Object}  listbox  ScriptUI listbox.
 */
function selectOnDoubleClick(listbox) {
  listbox.onDoubleClick = function () {
    if (listbox.selection) listbox.window.close(1);
  };
}

/**
 * Add listbox command to Workflow when double-clicking.
 * @param {Object}  listbox  ScriptUI listbox.
 */
function addToWorkflowOnDoubleClick(listbox) {
  listbox.onDoubleClick = function () {
    if (listbox.selection) {
      var win = listbox.window;
      var steps = win.findElement("workflowSteps");
      steps.add("item", listbox.selection);
      steps.notify("onChange");
    }
  };
}

/**
 * Allow end-to-end scrolling from within a listbox.
 * @param {Object}  listbox  ScriptUI listbox.
 */
function scrollListBoxWithArrows(listbox) {
  listbox.addEventListener("keydown", function (e) {
    if (e.fromQuery) {
      if (e.fromQueryShiftKey) {
        if (e.keyName == "Up") {
          if (this.selection.index == 0) {
            this.selection = this.items.length - 1;
            e.preventDefault();
          } else {
            this.selection--;
          }
        }
        if (e.keyName == "Down") {
          if (this.selection.index == this.items.length - 1) {
            this.selection = 0;
            e.preventDefault();
          } else {
            if (e.keyName == "Down") this.selection++;
          }
        }
      } else {
        if (e.keyName == "Up" || e.keyName == "Down") {
          if (e.keyName == "Up") {
            e.preventDefault();
            if (!this.selection) {
              this.selection = 0;
            } else if (this.selection.index == 0) {
              // jump to the bottom if at top
              this.selection = this.items.length - 1;
              this.frameStart = this.items.length - 1 - visibleListItems;
            } else {
              if (this.selection.index > 0) {
                this.selection = this.selection.index - 1;
                if (this.selection.index < this.frameStart) this.frameStart--;
              }
            }
          } else if (e.keyName == "Down") {
            e.preventDefault();
            if (!this.selection) {
              this.selection = 0;
            } else if (this.selection.index === this.items.length - 1) {
              // jump to the top if at the bottom
              this.selection = 0;
              this.frameStart = 0;
            } else {
              if (this.selection.index < this.items.length) {
                this.selection = this.selection.index + 1;
                if (this.selection.index > this.frameStart + visibleListItems - 1) {
                  if (this.frameStart < this.items.length - visibleListItems) {
                    this.frameStart++;
                  } else {
                    this.frameStart = this.frameStart;
                  }
                }
              }
            }
          }
          /*
        If a selection is made inside of the actual listbox frame by the user,
        the API doesn't offer any way to know which part of the list is currently
        visible in the listbox "frame". If the user was to re-enter the `q` edittext
        and then hit an arrow key the above event listener will not work correctly so
        I just move the next selection (be it up or down) to the middle of the "frame".
        */
          if (this.selection) {
            if (
              this.selection.index < this.frameStart ||
              this.selection.index > this.frameStart + visibleListItems - 1
            )
              this.frameStart = this.selection.index - Math.floor(visibleListItems / 2);
            // don't move the frame if list items don't fill the available rows
            if (this.items.length <= visibleListItems) return;
            // move the frame by revealing the calculated `this.frameStart`
            this.revealItem(this.frameStart);
          }
        }
      }
    } else {
      if (e.keyName == "Up" && this.selection.index == 0) {
        this.selection = this.items.length - 1;
        e.preventDefault();
      }
      if (e.keyName == "Down" && this.selection.index == this.items.length - 1) {
        this.selection = 0;
        e.preventDefault();
      }
    }
  });
}

// USER DIALOGS

function commandPalette(commands, title, multiselect, showOnly) {
  // create the dialog
  var win = new Window("dialog");
  win.text = title;
  win.alignChildren = "fill";

  // setup the query input
  var q = win.add("edittext");
  q.helpTip = localize(locStrings.cd_q_helptip);

  // setup the commands listbox
  var list = new ListBoxWrapper(
    showOnly ? showOnly : commands,
    win,
    paletteSettings.bounds,
    multiselect,
    null,
    [selectOnDoubleClick, scrollListBoxWithArrows]
  );

  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var ok = winButtons.add("button", undefined, "OK");
  ok.preferredSize.width = 100;
  var cancel = winButtons.add("button", undefined, localize(locStrings.cancel), {
    name: "cancel",
  });
  cancel.preferredSize.width = 100;

  // work-around to stop windows from flickering/flashing explorer
  if (windowsFlickerFix) {
    simulateKeypress("TAB", 1);
  } else {
    q.active = true;
  }

  // as a query is typed update the listbox
  var matches;
  q.onChanging = function () {
    if (this.text === "") {
      matches = showOnly ? showOnly : commands;
    } else {
      matches = scoreMatches(this.text, commands);
    }
    if (matches.length > 0) {
      list.update(matches);
    }
  };

  // allow using arrow key from query input by sending a custom keyboard event to the list box
  if (!multiselect) {
    var kbEvent = ScriptUI.events.createEvent("KeyboardEvent");
    q.addEventListener("keydown", function (e) {
      // hack to keep original commands from reloading before closing command palette when hitting the escape key while within the query box
      if (e.keyName == "Escape") {
        e.preventDefault();
        win.close();
      }
      if (e.keyName == "Up" || e.keyName == "Down") {
        kbEvent.initKeyboardEvent(
          "keydown",
          true,
          true,
          list.listbox,
          e.keyName,
          0,
          ""
        );
        kbEvent.fromQuery = true;
        kbEvent.fromQueryShiftKey = e.getModifierState("shift");
        list.listbox.dispatchEvent(kbEvent);
        e.preventDefault();
      }
    });
  }

  if (win.show() == 1) {
    if (list.listbox.selection) {
      return multiselect ? list.listbox.selection : [list.listbox.selection];
    }
  }
  return false;
}

function workflowBuilder(commands, editWorkflow, editCommands) {
  // create the dialog
  var win = new Window("dialog");
  win.text = locStrings.wf_builder;
  win.alignChildren = "fill";

  // setup the query input
  var pSearch = win.add("panel", undefined, localize(locStrings.cd_search_for));
  pSearch.alignChildren = ["fill", "center"];
  pSearch.margins = 20;
  var q = pSearch.add("edittext");
  q.helpTip = localize(locStrings.cd_q_helptip);

  // setup the commands listbox
  var list = new ListBoxWrapper(
    commands,
    win,
    [0, 0, paletteSettings.paletteWidth + 40, paletteSettings.paletteHeight],
    true,
    localize(locStrings.cd_helptip),
    [addToWorkflowOnDoubleClick, scrollListBoxWithArrows]
  );

  // work-around to stop windows from flickering/flashing explorer
  if (windowsFlickerFix) {
    simulateKeypress("TAB", 1);
  } else {
    q.active = true;
  }

  // workflow steps
  var pSteps = win.add("panel", undefined, localize(locStrings.wf_steps));
  pSteps.alignChildren = ["fill", "center"];
  pSteps.margins = 20;
  var steps = pSteps.add(
    "listbox",
    [0, 0, paletteSettings.paletteWidth + 40, paletteSettings.paletteHeight],
    editWorkflow ? editCommands : [],
    {
      name: "workflowSteps",
      multiselect: true,
    }
  );
  steps.helpTip = localize(locStrings.wf_steps_helptip);
  var stepButtons = pSteps.add("group");
  stepButtons.alignment = "center";
  var up = stepButtons.add("button", undefined, localize(locStrings.step_up));
  up.preferredSize.width = 100;
  var down = stepButtons.add("button", undefined, localize(locStrings.step_down));
  down.preferredSize.width = 100;
  var del = stepButtons.add("button", undefined, localize(locStrings.step_delete));
  del.preferredSize.width = 100;

  // command name
  var pName = win.add("panel", undefined, localize(locStrings.wf_save_as));
  pName.alignChildren = ["fill", "center"];
  pName.margins = 20;
  var workflowNameText = editWorkflow ? editWorkflow : "";
  var workflowName = pName.add("edittext", undefined, workflowNameText);
  workflowName.enabled = editWorkflow ? true : false;

  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var ok = winButtons.add("button", undefined, "OK");
  ok.preferredSize.width = 100;
  ok.enabled = editWorkflow ? true : false;
  var cancel = winButtons.add("button", undefined, localize(locStrings.cancel), {
    name: "cancel",
  });
  cancel.preferredSize.width = 100;

  // as a query is typed update the listbox
  var matches;
  q.onChanging = function () {
    if (this.text === "") {
      matches = commands;
    } else {
      matches = scoreMatches(this.text, commands);
    }
    if (matches.length > 0) {
      list.update(matches);
    }
  };

  steps.onChange = function () {
    workflowName.enabled = steps.items.length > 0 ? true : false;
    ok.enabled = steps.items.length > 0 && workflowName.text.length > 0 ? true : false;
  };

  workflowName.onChanging = function () {
    ok.enabled = workflowName.text.length > 0 ? true : false;
  };

  up.onClick = function () {
    var selected = sortIndexes(steps.selection);
    if (selected[i] == 0 || !contiguous(selected)) return;
    for (var i = 0; i < selected.length; i++)
      swap(steps.items[selected[i] - 1], steps.items[selected[i]]);
    steps.selection = null;
    for (var n = 0; n < selected.length; n++) steps.selection = selected[n] - 1;
  };

  down.onClick = function () {
    var selected = sortIndexes(steps.selection);
    if (
      selected[selected.length - 1] == steps.items.length - 1 ||
      !contiguous(selected)
    )
      return;
    for (var i = steps.selection.length - 1; i > -1; i--)
      swap(steps.items[selected[i]], steps.items[selected[i] + 1]);
    steps.selection = null;
    for (var n = 0; n < selected.length; n++) steps.selection = selected[n] + 1;
  };

  // the api returns the selected items in the order they were
  // selected/clicked by the user when you call `list.selection`
  // so their actual listbox indexes need to be sorted for the
  // up, down, and delete buttons to work when multiple items are selected
  function sortIndexes(sel) {
    var indexes = [];
    for (var i = 0; i < sel.length; i++) indexes.push(sel[i].index);
    return indexes.sort();
  }

  // check to make sure selection is contiguous
  function contiguous(sel) {
    return sel.length == sel[sel.length - 1] - sel[0] + 1;
  }

  /** swap listbox items in place */
  function swap(x, y) {
    var t = x.text;
    x.text = y.text;
    y.text = t;
  }

  del.onClick = function () {
    var selected = sortIndexes(steps.selection);
    for (var i = steps.selection.length - 1; i > -1; i--) {
      steps.remove(selected[i]);
    }
    steps.selection == null;
    workflowName.enabled = steps.items.length > 0 ? true : false;
    ok.enabled = steps.items.length > 0 && workflowName.text.length > 0 ? true : false;
  };

  if (win.show() == 1) {
    return { name: workflowName.text.trim(), actions: steps.items };
  }
  return false;
}

/**
 * Present File.openDialog() for user to select files to load.
 * @param   {String}  prompt        Prompt for dialog.
 * @param   {Boolean} multiselect   Can multiple files be selected.
 * @param   {String}  fileTypeRegex RegEx search string for file types (e.g. ".jsx$|.js$").
 * @returns {Array}                 Selected file(s).
 */
function loadFileTypes(prompt, multiselect, fileTypeRegex) {
  var results = [];
  var files = File.openDialog(prompt, "", multiselect);
  if (files) {
    for (var i = 0; i < files.length; i++) {
      f = files[i];
      fname = decodeURI(f.name);
      if (f.name.search(fileTypeRegex) >= 0) {
        results.push(f);
      }
    }
  }
  return results;
}

/**
 * close list on double-click of list item
 * @param {Object} listbox ScriptUI ListBox.
 */
function selectOnDoubleClick(listbox) {
  win = listbox.parent;
  listbox.onDoubleClick = function () {
    if (listbox.selection) win.close(1);
  };
}
