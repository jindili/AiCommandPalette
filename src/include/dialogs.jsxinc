// USER DIALOGS

/**
 * Show a filterable commands palette.
 * @param   {Array}   commands      Commands available to the palette.
 * @param   {Boolean} showHidden    Should user hidden commands be shown in the palette.
 * @param   {Array}   queryFilter   Types of commands to hide from the search query.
 * @param   {Array}   visibleFilter Types of commands to hide from the initial view.
 * @param   {String}  title         Command palette title.
 * @param   {Array}   bounds        Command palette bounds.
 * @param   {Boolean} multiselect   Can multiple items be selected.
 * @param   {Boolean} docRequired   Should commands requiring an active document to work be hidden if there is no active document.
 * @param   {Boolean} selRequired   Should commands requiring an active selection to work be hidden if there is no active selection.
 * @returns {Array}                 Array of selected list items.
 */
function commandPalette(
  commands,
  showHidden,
  queryFilter,
  visibleFilter,
  title,
  bounds,
  multiselect,
  docRequired,
  selRequired
) {
  // insert command and type into listbox
  function insertCommands(list, commands) {
    var command, commandData;
    for (var i = 0; i < commands.length; i++) {
      command = commands[i];
      commandData = commandsData[localizedCommandLookup[command]];
      with (list.add("item", command)) {
        subItems[0].text = commandData.type; // TODO: add localization
      }
    }
  }

  commands = filterCommands(
    commands,
    queryFilter,
    visibleFilter,
    showHidden,
    [],
    docRequired,
    selRequired
  );

  // create the dialog
  var win = new Window("dialog");
  win.text = title;
  win.alignChildren = "fill";
  var q = win.add("edittext");
  q.helpTip = localize(locStrings.cd_q_helptip);

  // setup the commands listbox
  var list = win.add("listbox", bounds, undefined, {
    numberOfColumns: paletteSettings.listboxProperties.numberOfColumns,
    showHeaders: paletteSettings.listboxProperties.showHeaders,
    columnTitles: paletteSettings.listboxProperties.columnTitles,
    columnWidths: paletteSettings.listboxProperties.columnWidths,
    multiselect: multiselect,
  });
  insertCommands(list, commands.visible);
  list.selection = 0;

  // close list on double-click of list item
  list.onDoubleClick = function () {
    if (list.selection) win.close(1);
  };

  // work-around to stop windows from flickering/flashing explorer
  if (windowsFlickerFix) {
    simulateKeypress("TAB", 1);
  } else {
    q.active = true;
  }

  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var ok = winButtons.add("button", undefined, "OK");
  ok.preferredSize.width = 100;
  var cancel = winButtons.add("button", undefined, localize(locStrings.cancel), {
    name: "cancel",
  });
  cancel.preferredSize.width = 100;

  // as a query is typed update the list box
  var matches, temp;
  var frameStart = 0;
  q.onChanging = function () {
    frameStart = 0;
    matches =
      this.text === "" ? commands.visible : scoreMatches(this.text, commands.query);
    if (matches.length > 0) {
      // setup the temp commands listbox
      var temp = win.add("listbox", list.bounds, undefined, {
        numberOfColumns: list.properties.numberOfColumns,
        showHeaders: list.properties.showHeaders,
        columnTitles: list.properties.columnTitles,
        columnWidths: list.properties.columnWidths,
        multiselect: list.properties.multiselect,
      });
      insertCommands(temp, matches);
      // temp.selection = 0;

      // close list on double-click of list item
      temp.onDoubleClick = function () {
        if (temp.selection) win.close(1);
      };

      // change the original listbox reference to the updated `temp` version
      win.remove(list);
      list = temp;
      // reset the selection
      list.selection = 0;
    }
  };

  if (!multiselect && list.items.length > 0) {
    /*
    Move the listbox frame of visible items when using the
    up and down arrow keys while in the `q` edittext.

    One problem with this functionality is that when a listbox listitem
    is selected via a script the API moves the visible "frame" of items
    so that the new selection is at the top. This is not standard behavior,
    and not even how the listbox behaves when you use the up and down keys inside
    of the actual listbox.

    Only works if multiselect if set to false.
    */
    q.addEventListener("keydown", function (k) {
      if (k.keyName == "Up" || k.keyName == "Down") {
        if (k.keyName == "Up") {
          k.preventDefault();
          if (!list.selection) {
            list.selection = 0;
          } else {
            if (list.selection.index > 0) {
              list.selection = list.selection.index - 1;
              if (list.selection.index < frameStart) frameStart--;
            }
          }
        } else if (k.keyName == "Down") {
          k.preventDefault();
          if (!list.selection) {
            list.selection = 0;
          } else {
            if (list.selection.index < list.items.length) {
              list.selection = list.selection.index + 1;
              if (list.selection.index > frameStart + visibleListItems - 1) {
                if (frameStart < list.items.length - visibleListItems) {
                  frameStart++;
                } else {
                  frameStart = frameStart;
                }
              }
            }
          }
        }
        /*
      If a selection is made inside of the actual listbox frame by the user,
      the API doesn't offer any way to know which part of the list is currently
      visible in the listbox "frame". If the user was to re-enter the `q` edittext
      and then hit an arrow key the above event listener will not work correctly so
      I just move the next selection (be it up or down) to the middle of the "frame".
      */
        if (list.selection) {
          if (
            list.selection.index < frameStart ||
            list.selection.index > frameStart + visibleListItems - 1
          )
            frameStart = list.selection.index - Math.floor(visibleListItems / 2);
          // move the frame by revealing the calculated `frameStart`
          list.revealItem(frameStart);
        }
      }
    });
  }

  if (win.show() == 1) {
    if (list.selection) {
      return multiselect ? list.selection : [list.selection];
    }
  }
  return false;
}

function goToPalette(commands, title, bounds) {
  // copy the commands
  var matches = commands;

  // create the dialog
  var win = new Window("dialog");
  win.text = title;
  win.alignChildren = "fill";
  var q = win.add("edittext");
  q.helpTip = localize(locStrings.cd_q_helptip);

  // work-around to stop windows from flickering/flashing explorer
  if (windowsFlickerFix) {
    simulateKeypress("TAB", 1);
  } else {
    q.active = true;
  }

  // setup the commands listbox
  var list = win.add("listbox", bounds, [], paletteSettings.listboxProperties);

  // add items to list
  for (var i = 0; i < matches.length; i++) {
    switch (matches[i].typename) {
      case "Document":
        var colormode =
          "(" + matches[i].documentColorSpace.toString().split(".").pop() + ")";
        matches[i]["queryName"] =
          matches[i] == app.activeDocument
            ? "x " + matches[i].name + " " + colormode
            : "   " + matches[i].name + " " + colormode;
        break;
      case "PlacedItem":
        matches[i]["queryName"] = matches[i].file.name;
        break;
      case "SymbolItem":
        matches[i]["queryName"] =
          matches[i].name || matches[i].name.length
            ? matches[i].name
            : matches[i].symbol.name;
        break;
      default:
        matches[i]["queryName"] = matches[i].name;
        break;
    }
    with (list.add("Item", truncateCommandName(matches[i].queryName, 50))) {
      subItems[0].text = matches[i].typename;
    }
  }
  list.selection = 0;

  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var ok = winButtons.add("button", undefined, "OK");
  ok.preferredSize.width = 100;
  var cancel = winButtons.add("button", undefined, localize(locStrings.cancel), {
    name: "cancel",
  });
  cancel.preferredSize.width = 100;

  // as a query is typed update the list box
  var matches, temp;
  var frameStart = 0;
  q.onChanging = function () {
    frameStart = 0;
    matches =
      this.text === "" ? commands : scoreObjectMatches(this.text, matches, "queryName");
    if (matches.length > 0) {
      var temp = win.add("listbox", list.bounds, [], {
        numberOfColumns: list.properties.numberOfColumns,
        showHeaders: list.properties.showHeaders,
        columnTitles: list.properties.columnTitles,
        columnWidths: list.properties.columnWidths,
      });

      for (var i = 0; i < matches.length; i++) {
        with (temp.add("Item", truncateCommandName(matches[i].queryName, 50))) {
          subItems[0].text = matches[i].typename;
        }
      }
      // close window when double-clicking a selection
      temp.onDoubleClick = function () {
        if (list.selection) win.close(1);
      };
      // remove the temp 'truncation fix' item from the list
      if (matches != commands.visible) temp.remove(temp.items.length - 1);
      win.remove(list);
      list = temp;
      list.selection = 0;
    }
  };

  if (list.items.length > 0) {
    /*
    Move the listbox frame of visible items when using the
    up and down arrow keys while in the `q` edittext.

    One problem with this functionality is that when a listbox listitem
    is selected via a script the API moves the visible "frame" of items
    so that the new selection is at the top. This is not standard behavior,
    and not even how the listbox behaves when you use the up and down keys inside
    of the actual listbox.

    Only works if multiselect if set to false.
    */
    q.addEventListener("keydown", function (k) {
      if (k.keyName == "Up" || k.keyName == "Down") {
        if (k.keyName == "Up") {
          k.preventDefault();
          if (!list.selection) {
            list.selection = 0;
          } else {
            if (list.selection.index > 0) {
              list.selection = list.selection.index - 1;
              if (list.selection.index < frameStart) frameStart--;
            }
          }
        } else if (k.keyName == "Down") {
          k.preventDefault();
          if (!list.selection) {
            list.selection = 0;
          } else {
            if (list.selection.index < list.items.length) {
              list.selection = list.selection.index + 1;
              if (list.selection.index > frameStart + visibleListItems - 1) {
                if (frameStart < list.items.length - visibleListItems) {
                  frameStart++;
                } else {
                  frameStart = frameStart;
                }
              }
            }
          }
        }
        /*
      If a selection is made inside of the actual listbox frame by the user,
      the API doesn't offer any way to know which part of the list is currently
      visible in the listbox "frame". If the user was to re-enter the `q` edittext
      and then hit an arrow key the above event listener will not work correctly so
      I just move the next selection (be it up or down) to the middle of the "frame".
      */
        if (list.selection) {
          if (
            list.selection.index < frameStart ||
            list.selection.index > frameStart + visibleListItems - 1
          )
            frameStart = list.selection.index - Math.floor(visibleListItems / 2);
          // move the frame by revealing the calculated `frameStart`
          list.revealItem(frameStart);
        }
      }
    });
  }

  function truncateCommandName(s, n) {
    return s.length <= n ? s : s.slice(0, n) + "...";
  }

  // close window when double-clicking a selection
  list.onDoubleClick = function () {
    if (list.selection) win.close(1);
  };

  if (win.show() == 1) {
    if (list.selection) {
      return matches[list.selection.index];
    }
  }
  return false;
}

function workflowBuilder(commands, showHidden, queryFilter, visibleFilter, edit) {
  // if editing a command, pull in variables to prefill dialog with
  var command;
  var actions = [];
  var hideCommands = [];
  if (edit != undefined) {
    command = commandsData[localizedCommandLookup[edit]];
    for (var i = 0; i < command.actions.length; i++) {
      actions.push(idCommandLookup[command.actions[i]]);
    }
    // make sure workflows can't include themselves
    hideCommands.push(edit);
  }

  // filter the commands based on supplied args
  // make it so you don't have to specify the same array
  // for both filters if they should be the same
  if (visibleFilter.length == 0) visibleFilter = queryFilter;
  commands = filterCommands(
    commands,
    queryFilter,
    visibleFilter,
    showHidden,
    hideCommands
  );

  // create the dialog
  var win = new Window("dialog");
  win.text = localize(locStrings.wf_builder);
  win.alignChildren = "fill";

  // command search
  var pSearch = win.add("panel", undefined, localize(locStrings.cd_search_for));
  pSearch.alignChildren = ["fill", "center"];
  pSearch.margins = 20;
  var q = pSearch.add("edittext");
  q.helpTip = localize(locStrings.cd_q_helptip);

  // work-around to stop windows from flickering/flashing explorer
  if (windowsFlickerFix) {
    simulateKeypress("TAB", 1);
  } else {
    q.active = true;
  }

  var list = pSearch.add(
    "listbox",
    [0, 0, paletteSettings.paletteWidth + 40, paletteSettings.paletteHeight],
    commands.visible,
    {
      multiselect: false,
    }
  );
  list.helpTip = localize(locStrings.cd_helptip);
  list.selection = 0;

  // workflow steps
  var pSteps = win.add("panel", undefined, localize(locStrings.wf_steps));
  pSteps.alignChildren = ["fill", "center"];
  pSteps.margins = 20;
  var steps = pSteps.add(
    "listbox",
    [0, 0, paletteSettings.paletteWidth + 40, paletteSettings.paletteHeight],
    actions,
    {
      multiselect: true,
    }
  );
  steps.helpTip = localize(locStrings.wf_steps_helptip);
  var stepButtons = pSteps.add("group");
  stepButtons.alignment = "center";
  var up = stepButtons.add("button", undefined, localize(locStrings.step_up));
  up.preferredSize.width = 100;
  var down = stepButtons.add("button", undefined, localize(locStrings.step_down));
  down.preferredSize.width = 100;
  var del = stepButtons.add("button", undefined, localize(locStrings.step_delete));
  del.preferredSize.width = 100;

  // command name
  var pName = win.add("panel", undefined, localize(locStrings.wf_save_as));
  pName.alignChildren = ["fill", "center"];
  pName.margins = 20;
  var workflowNameText = edit == undefined ? "" : edit;
  var workflowName = pName.add("edittext", undefined, workflowNameText);
  workflowName.enabled = edit == undefined ? false : true;

  // window buttons
  var winButtons = win.add("group");
  winButtons.orientation = "row";
  winButtons.alignChildren = ["center", "center"];
  var ok = winButtons.add("button", undefined, "OK");
  ok.preferredSize.width = 100;
  ok.enabled = edit == undefined ? false : true;
  var cancel = winButtons.add("button", undefined, localize(locStrings.cancel), {
    name: "cancel",
  });
  cancel.preferredSize.width = 100;

  // as a query is typed update the list box
  var matches, temp;
  q.onChanging = function () {
    matches =
      this.text === "" ? commands.visible : scoreMatches(this.text, commands.visible);
    if (matches.length > 0) {
      temp = pSearch.add("listbox", list.bounds, matches, {
        multiselect: list.properties.multiselect,
      });
      // add command when double-clicking
      temp.onDoubleClick = list.onDoubleClick;
      // remove the temp 'truncation fix' item from the list
      if (matches != commands.visible) temp.remove(temp.items.length - 1);
      // change the original listbox reference to the updated `temp` version
      pSearch.remove(list);
      list = temp;
      // reset the selection
      list.selection = 0;
      cur = 0;
    }
  };

  workflowName.onChanging = function () {
    ok.enabled = workflowName.text.length > 0 ? true : false;
  };

  up.onClick = function () {
    var selected = sortIndexes(steps.selection);
    if (selected[i] == 0 || !contiguous(selected)) return;
    for (var i = 0; i < selected.length; i++)
      swap(steps.items[selected[i] - 1], steps.items[selected[i]]);
    steps.selection = null;
    for (var n = 0; n < selected.length; n++) steps.selection = selected[n] - 1;
  };

  down.onClick = function () {
    var selected = sortIndexes(steps.selection);
    if (
      selected[selected.length - 1] == steps.items.length - 1 ||
      !contiguous(selected)
    )
      return;
    for (var i = steps.selection.length - 1; i > -1; i--)
      swap(steps.items[selected[i]], steps.items[selected[i] + 1]);
    steps.selection = null;
    for (var n = 0; n < selected.length; n++) steps.selection = selected[n] + 1;
  };

  // the api returns the selected items in the order they were
  // selected/clicked by the user when you call `list.selection`
  // so their actual listbox indexes need to be sorted for the
  // up, down, and delete buttons to work when multiple items are selected
  function sortIndexes(sel) {
    var indexes = [];
    for (var i = 0; i < sel.length; i++) indexes.push(sel[i].index);
    return indexes.sort();
  }

  // check to make sure selection is contiguous
  function contiguous(sel) {
    return sel.length == sel[sel.length - 1] - sel[0] + 1;
  }

  /** swap listbox items in place */
  function swap(x, y) {
    var t = x.text;
    x.text = y.text;
    y.text = t;
  }

  del.onClick = function () {
    var selected = sortIndexes(steps.selection);
    for (var i = steps.selection.length - 1; i > -1; i--) {
      steps.remove(selected[i]);
    }
    steps.selection == null;
    workflowName.enabled = steps.items.length > 0 ? true : false;
    ok.enabled = workflowName.text.length > 0 ? true : false;
  };

  list.onDoubleClick = function () {
    if (list.selection) {
      steps.add("item", list.selection);
      workflowName.enabled = steps.items.length > 0 ? true : false;
      ok.enabled = workflowName.text.length > 0 ? true : false;
    }
  };

  if (win.show() == 1) {
    return { name: workflowName.text.trim(), actions: steps.items };
  }
  return false;
}

/**
 * Present File.openDialog() for user to select files to load.
 * @param   {String}  prompt        Prompt for dialog.
 * @param   {Boolean} multiselect   Can multiple files be selected.
 * @param   {String}  fileTypeRegex RegEx search string for file types (e.g. ".jsx$|.js$").
 * @returns {Array}                 Selected file(s).
 */
function loadFileTypes(prompt, multiselect, fileTypeRegex) {
  var results = [];
  var files = File.openDialog(prompt, "", multiselect);
  if (files) {
    for (var i = 0; i < files.length; i++) {
      f = files[i];
      fname = decodeURI(f.name);
      if (f.name.search(fileTypeRegex) >= 0) {
        results.push(f);
      }
    }
  }
  return results;
}
